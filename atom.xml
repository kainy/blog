<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Freetao&#39;s Blog</title>
  
  <subtitle>关♥生活，关注互联网。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blogs.kainy.cn/"/>
  <updated>2018-12-14T09:35:52.000Z</updated>
  <id>https://blogs.kainy.cn/</id>
  
  <author>
    <name>Kainy Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微海报2018前端性能回顾</title>
    <link href="https://blogs.kainy.cn/2018/12/%E5%BE%AE%E6%B5%B7%E6%8A%A52018%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E5%9B%9E%E9%A1%BE/"/>
    <id>https://blogs.kainy.cn/2018/12/微海报2018前端性能回顾/</id>
    <published>2018-12-11T22:20:16.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>又到一年之末，回顾的时候。</p><p>年初使用 speedtracker 搭建了微海报性能监控——speedtracker 是基于免费性能评估服务 webpagetest 的工具，会定期跑分，并记录。串起来形成一份时间线报告。好处是配置简单，托管在 Github 上自动运行，无需服务器资源。缺点是数据存储在静态文件中，所以时间段只能选择过去一天、一周、一月、或者一年，而不能选择指定起止时间。也无法纪录超出一年的数据，所以现在正是分析过去一年数据的好时点～</p><a id="more"></a><p>先来看<code>页面加载时长曲线</code>：</p><p><a href="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy3slhd665j214i0u0wyz.jpg" target="_blank" rel="noopener"><img src="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy3slhd665j214i0u0wyz.jpg" alt="页面加载时长" title="页面加载时长"></a></p><p>可以看出，左右两端有两个比较明显的突起，时间点在黑色气泡展示，把整条曲线分为三个部分，凸起部分是前端性能瓶颈期， 两个凸起部分右边的向下断崖，对应实施优化的时间点。</p><p>第一次优化大约在三月份，当时采取的措施是采用cdn厂商提供的图片缩放功能，在列表页加载缩略图。</p><p>第二次优化在十一月23，这次界面彻底改版，将原本一次加载所有数据的方式，改为一次加载所选分类海报，同时支持分页。</p><p><a href="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy49cukb2tj20sg0lck5y.jpg" target="_blank" rel="noopener"><img src="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy49cukb2tj20sg0lck5y.jpg" alt="微海报UI改版前后对比" title="微海报UI改版前后对比"></a></p><p>上图中，右边是改版后的UI，可以看到顶部新增了搜索功能，下面是原先在底部的分类按钮，支持无限分类，左右划动可以查看更多，海报列表支持“热门”和“最新”两种排序，并且支持分页。</p><p>项目初期由于海报数量有限，图片懒加载足以应对，而一次拉取所有数据，前端可以更灵活的满足交互需求。但是随着时间推移，微海报承载的活动量逐步上升，十月份后投放量激增，导致性能瓶颈凸显，内容运营上原有分类数量无法拓展的问题，也限制了业务同事发挥。于是有了十一月份的改版优化需求。</p><p>改版面临的主要难点是：支持分页后，已经加载分页列表数据的缓存，以及定位到指定某站海报的支持——尤其是指定海报在很靠后的某个分页的情况。具体细节先不在这里展开。继续看图：</p><p><a href="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy3yg27vz1j21470u01a2.jpg" target="_blank" rel="noopener"><img src="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy3yg27vz1j21470u01a2.jpg" alt="页面内容请求数量曲线" title="页面内容请求数量曲线"></a></p><p>从<code>页面内容请求数量曲线</code>中看出，图片请求数在增加，反映出投放海报的增加、业务的增长。三月份的缩略图优化仅缩小了每张图的尺寸，对请求数量无影响，而十一月份对分页优化，效果则十分明显。</p><p><a href="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy3t1m1rjqj21520u07h0.jpg" target="_blank" rel="noopener"><img src="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy3t1m1rjqj21520u07h0.jpg" alt="页面内容下载文件尺寸曲线" title="页面内容下载文件尺寸曲线"></a></p><p>从<code>页面内容下载文件尺寸</code>曲线，则可以看到，两次优化对此指标都有较大影响。三月的缩略图优化，只是延迟了瓶颈期，随着海报投放量增加，还是会达到天花板；而十一月份分页优化，则理论上彻底打破了数量的天花板，很大程度扩展了微海报的内容承载能力。</p><p><a href="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy3yg4hxi2j214a0u0gun.jpg" target="_blank" rel="noopener"><img src="https://wx3.sinaimg.cn/large/4d6e3e3bgy1fy3yg4hxi2j214a0u0gun.jpg" alt="跑分曲线" title="跑分曲线"></a></p><p>经过前面分析，<code>跑分曲线</code>也就不难理解了，下载量和请求数降低和评分提升正相关，Lighthouse PWA 得分有一段突起，具体原因仍待分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又到一年之末，回顾的时候。&lt;/p&gt;&lt;p&gt;年初使用 speedtracker 搭建了微海报性能监控——speedtracker 是基于免费性能评估服务 webpagetest 的工具，会定期跑分，并记录。串起来形成一份时间线报告。好处是配置简单，托管在 Github 上自动运行，无需服务器资源。缺点是数据存储在静态文件中，所以时间段只能选择过去一天、一周、一月、或者一年，而不能选择指定起止时间。也无法纪录超出一年的数据，所以现在正是分析过去一年数据的好时点～&lt;/p&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="工作" scheme="https://blogs.kainy.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="复盘" scheme="https://blogs.kainy.cn/tags/%E5%A4%8D%E7%9B%98/"/>
    
      <category term="性能" scheme="https://blogs.kainy.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="优化" scheme="https://blogs.kainy.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="回顾" scheme="https://blogs.kainy.cn/tags/%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>小程序分享网页方案</title>
    <link href="https://blogs.kainy.cn/2018/07/%E5%8D%9A%E5%AE%A2%EF%BC%8F%E8%B5%84%E8%AE%AF%E7%B1%BB%E7%BD%91%E9%A1%B5%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%86%E4%BA%AB%E7%9A%84%E6%96%B9%E6%A1%88/"/>
    <id>https://blogs.kainy.cn/2018/07/博客／资讯类网页在小程序中分享的方案/</id>
    <published>2018-07-31T09:55:04.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>TL;DR 可以点击<a href="#体验方式">这里体验</a>是否你需要的效果后，再回来看内容。</p><p>小程序卡片分享相比链接分享的优势不言而喻：更大的封面图片意味着可承载更多信息，和更强的视觉表现力；更大的面积，也意味着在聊天窗口中更容易被点到（算是额外福利）。但如果单纯为了发挥这一优势专门开发一个资讯小程序，其产出又不足以覆盖投入。</p><p>并且，为了方便传播和跨平台访问，H5无疑是最合适的内容载体。于是思路转化为：是否可以像iOS、安卓webview一样，打造一个小程序版的内容容器。小程序web-view组件就可以用来实现：微信生态内，优先通过小程序传播h5页面，同时将改造的开发量和影响降到最低这一需求。<br><a id="more"></a></p><h2 id="分享发起侧"><a href="#分享发起侧" class="headerlink" title="分享发起侧"></a>分享发起侧</h2><p>小程序web-view组件的属性很简单，要完成分享功能，只要在网页中监听用户触发的分享操作事件，然后通过JSSDK的wx.miniProgram.postMessage方法将分享信息（页面URL、文章标题、描述、封面地址）发送给小程序，小程序接收后指引用户“点击右上角菜单”进行分享，当用户执行分享操作触发onShareAppMessage时，使用网页传递来的分享信息即可。</p><p>该方案的局限性在于：</p><ol><li><p>web-view会铺满这个屏幕，也就意味着没有引导海报合成操作的交互空间，而小程序分享到朋友圈，目前只能通过图片方式</p></li><li><p>分享操作的指引不够直观，“点击右上角菜单“对于不熟悉小程序的用户，很可能就点到菜单按钮右边的“关闭”按钮而一去不复返了，毕竟这个位置才真正意义上的”右上角“</p></li></ol><p>为了解决上述问题，考虑单独打开一个小程序页面，专门用来做分享操作指引。这个页面上有足够的空间放一个足够醒目的”分享“按钮，再摆一个”保存海报并分享到朋友圈“按钮，以及用封面图片和文章标题、简介合成的海报预览，如有需要，甚至可以增加用户输入信息，或者登录按钮为链接添加分享者信息。该方案看似增加了一步跳转，但这个指引更加直观。也大大扩展了分享的能力。</p><p>需要注意的是，合成海报用到到URL需要进行短地址处理，因为小程序码参数长度有限，如不使用短地址，很容易造成小程序码生成失败。不过为了便于更广泛地传播，这里不建议使用小程序码，而是直接使用文章页URL生成普通二维码，配合“扫普通链接二维码打开小程序”配置，实现微信内小程序打开，微信外普通webview打开网页。</p><h2 id="分享接收侧"><a href="#分享接收侧" class="headerlink" title="分享接收侧"></a>分享接收侧</h2><p>用户收到小程序卡片消息，点开后打开web-view，将src填入，即可查看博文；</p><p>通过海报识别二维码打开URL，因为配置了“扫普通链接二维码打开小程序”也会直接打开web-view小程序页面，这时候通过接收q参数，可以获取到二维码链接内容（在onLoad事件中提取”q”参数并自行UrlDecode一次，即可获取原二维码的完整内容）；</p><p>另一方面，网页需要做的是：根据 wx.miniProgram.getEnv 获取当前网页加载环境，如果是小程序中，则露出分享按钮。并过滤掉非业务域名的链接和iframe。</p><h2 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h2><p>在利用小程序卡片的优势，促进内容和活动页面在微信生态内传播都同时，反过来，也是利用内容为自己的小程序拉新。结合小程序的设备、媒体、微信支付、卡券等能力，更好的完成服务变现。</p><p>可以看到近两年来微信含蓄而一以贯之地表达着做大做强小程序的意志，仿佛意图将小程序能承载的都收入其中… 不过即便果真如此又怎样？还是那句话“谁让你在别人的地盘”，更重要的是目标客户在微信的地盘。如果不能反抗，就一定要学会享受，非要押注爆冷的话，可以同时祈祷有一天所有人都弃微信而去。</p><h2 id="体验方式"><a href="#体验方式" class="headerlink" title="体验方式"></a>体验方式</h2><p>如果你查看这篇文章时</p><ul><li><p>在小程序外：（朋友圈，聊天会话）扫描图上二维码体验<br><center><img width="60%" src="https://wx2.sinaimg.cn/mw690/4d6e3e3bgy1ftssuoubn4j20ku14gx12.jpg" alt="微海报"></center><br>-</p></li><li><p>在小程序内：点击文末绿色“分享”按钮。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TL;DR 可以点击&lt;a href=&quot;#体验方式&quot;&gt;这里体验&lt;/a&gt;是否你需要的效果后，再回来看内容。&lt;/p&gt;&lt;p&gt;小程序卡片分享相比链接分享的优势不言而喻：更大的封面图片意味着可承载更多信息，和更强的视觉表现力；更大的面积，也意味着在聊天窗口中更容易被点到（算是额外福利）。但如果单纯为了发挥这一优势专门开发一个资讯小程序，其产出又不足以覆盖投入。&lt;/p&gt;&lt;p&gt;并且，为了方便传播和跨平台访问，H5无疑是最合适的内容载体。于是思路转化为：是否可以像iOS、安卓webview一样，打造一个小程序版的内容容器。小程序web-view组件就可以用来实现：微信生态内，优先通过小程序传播h5页面，同时将改造的开发量和影响降到最低这一需求。&lt;br&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="小程序" scheme="https://blogs.kainy.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="方案" scheme="https://blogs.kainy.cn/tags/%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>小程序工程化开发之：重构稿转为wxml</title>
    <link href="https://blogs.kainy.cn/2018/06/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BC%80%E5%8F%91%E4%B9%8B%EF%BC%9A%E9%87%8D%E6%9E%84%E7%A8%BF%E8%BD%AC%E4%B8%BAwxml/"/>
    <id>https://blogs.kainy.cn/2018/06/小程序工程化开发之：重构稿转为wxml/</id>
    <published>2018-06-12T23:03:13.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>在开发<code>微海报</code>小程序时，由于团队没有过小程序开发经历。按照常规流程，重构输出的是移动端 HTML 网页，以 rem 为尺寸单位。这与小程序的 wxml 和 rpx 之间有一个转化的过程，如果手工转化，无疑带来巨大的额外工作量，而让重构同学短期内熟练掌握小程序开发工具和一套新的标记语言又不太现实。<br><a id="more"></a></p><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>按照以往的前端工程分工：设计出图－&gt;重构出页面-&gt;逻辑和交互开发，我们需要新增一个步骤来消化小程序展示层与常规网页的差异，将转换工作平滑衔接进现有流程，以最小的投入达到小程序开发条件。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>明确了目标后，就可以找具体解决方案了，本着“不重复造轮子”的精神，先网上搜搜，果然这是一个比较通用的问题。京东凹凸团队早在17年6月就已开源了 <code>html-to-wxapp</code> ，按照操作指引试了一下，却没有得到预期的结果，研究了一番似乎是文件匹配写法问题，于是 <a href="https://github.com/kainy/html-to-wxapp" target="_blank" rel="noopener">fork 一份</a>动手修复了下，重新发布到 <a href="https://www.npmjs.com/package/h2a" target="_blank" rel="noopener">npm</a> 方便后续使用。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//安装</span><br><span class="line">npm install h2a -g</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>例如：源码<code>test</code>目录文件结构如下<br></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├──test</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── <span class="keyword">index</span>.html</span><br><span class="line">│   └── <span class="keyword">index</span>.css</span><br></pre></td></tr></table></figure><p></p><h3 id="执行："><a href="#执行：" class="headerlink" title="执行："></a>执行：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wxapp transfer <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>将会转换成：<br></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├──_wxapp_test</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── <span class="keyword">index</span>.wxml</span><br><span class="line">│   └── <span class="keyword">index</span>.wxss</span><br></pre></td></tr></table></figure><p></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li>转换工具对 html 标签进行替换并删除了 script 等标签及内容，将 css 里的 rem 单位替换成 rpx，并进行数值转换</li><li>stylelint 规则限制了动画和过渡的使用、限制了 img 之外的类型选择器、禁止了两层以上的级联</li><li>小程序的样式有许多限制，还需要手动调试</li><li>如果转换出来的样式尺寸不对，可以调整 config.js 里的 remTimes 参数，来符合自己团队的重构规范。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上介绍了一个将 html 及 css 转换成微信小程序的 wxml 和 wxss 的小工具，实现小程序开发与现有前端流程整合的过程。</p><p>最近发现越来越多小程序的界面变精致了，认真观察发现主要是由于采用自定义组件替换了以往一成不变的基础组件。后面的文章打算聊聊通过自定义组件实现模块化开发小程序，达到复杂度拆解和进度控制的工程化目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h2&gt;&lt;p&gt;在开发&lt;code&gt;微海报&lt;/code&gt;小程序时，由于团队没有过小程序开发经历。按照常规流程，重构输出的是移动端 HTML 网页，以 rem 为尺寸单位。这与小程序的 wxml 和 rpx 之间有一个转化的过程，如果手工转化，无疑带来巨大的额外工作量，而让重构同学短期内熟练掌握小程序开发工具和一套新的标记语言又不太现实。&lt;br&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="小程序" scheme="https://blogs.kainy.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="开发" scheme="https://blogs.kainy.cn/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="工程化" scheme="https://blogs.kainy.cn/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>总在深夜放大招，小程序官方团队真的没有性生活？</title>
    <link href="https://blogs.kainy.cn/2018/03/180328%E6%80%BB%E5%9C%A8%E6%B7%B1%E5%A4%9C%E6%94%BE%E5%A4%A7%E6%8B%9B%EF%BC%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%98%E6%96%B9%E5%9B%A2%E9%98%9F%E7%9C%9F%E7%9A%84%E6%B2%A1%E6%9C%89X%E7%94%9F%E6%B4%BB%EF%BC%9F/"/>
    <id>https://blogs.kainy.cn/2018/03/180328总在深夜放大招，小程序官方团队真的没有X生活？/</id>
    <published>2018-03-28T10:50:35.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wx4.sinaimg.cn/mw690/4d6e3e3bgy1fpzrnnn2dmj20hy134k1w.jpg" alt="小程序深夜放大招"></p><a id="more"></a><p>说到这个问题，就不得不提到腾讯的产品灰度发布策略——推送新特性通常是一个过程，在灰度发布期间小程序团队会逐步推送新特性到用户端，在扩大推送范围的同时监控曲线是否异动，</p><p><img src="https://wx4.sinaimg.cn/large/4d6e3e3bgy1fpsmyp4pztj20fs053jrg.jpg" alt="监控曲线"><br>（大概长上图这样子）</p><p>若直到灰度覆盖所有用户，曲线都没有明显异动，且上报日志没有收集到致命错误，则认为推送完成。这之后才发布新能力的文档及公众号推文。而一般灰度时长为12小时，也就说当我们在晚上发现小程序团队“搞事情”的时候，其实小程序团队已忙碌了12小时，基本可以收工回家，安心的做该做的事情了。。</p><p><img src="https://wx4.sinaimg.cn/mw690/4d6e3e3bgy1fpzrnoixmrj20hu136jzo.jpg" alt="小程序没有性生活"></p><p>至于为什么放任“没有性生活”的说法流传，我觉得有可能是运营的小心机——营造出一种”大神与你同在”的鸡血氛围，为开发者鼓劲——所以当小程序员苦逼哈哈地加班研究新特性时，真正与你深夜奋战也许不是大神而是你的寂寞… 😏</p><p>另一方面，如果把小程序征服星辰大海的过程比作马拉松，现阶段显然远未接近终点，运动员自然鲜有理会场外观众的闲情。所以也请大家别再误解低头赶路人的沉默啦～</p><p>好了，关于小程序官方团队<del>究竟有没有性生活的八卦</del>为什么总在深夜发版本的科普就到这里，希望解答了你的困惑。</p><p>（我怎么竟是如此八卦的一个人 😂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/mw690/4d6e3e3bgy1fpzrnnn2dmj20hy134k1w.jpg&quot; alt=&quot;小程序深夜放大招&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="小程序" scheme="https://blogs.kainy.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="灰度" scheme="https://blogs.kainy.cn/tags/%E7%81%B0%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>微海报离线优化小结</title>
    <link href="https://blogs.kainy.cn/2018/02/180210%E5%BE%AE%E6%B5%B7%E6%8A%A5%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/"/>
    <id>https://blogs.kainy.cn/2018/02/180210微海报图片优化小结/</id>
    <published>2018-02-10T10:50:35.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h3><p>由于业务发展</p><a id="more"></a><h3 id="workbox介绍"><a href="#workbox介绍" class="headerlink" title="workbox介绍"></a>workbox介绍</h3><p>workbox 是用来实现网页应用离线化的构建工具，通过生成的 service worker 文件，让你的离线静态资源管理策略得以在用户端实现。由于 service worker 本身是飞速发展规范，且客户端支持程度不一，通过调用 workerbox 的 API，可以最大程度的屏蔽这些兼容问题，从这个方面理解，有点像 jQuery 在 ie 时代的作用，差别是前者解决的是 service work 运行环境的兼容性问题，而 jQuery 解决的事浏览器兼容性问题。</p><p>workbox 本身集成了常用的五套缓存策略</p><ul><li>Cache only；</li><li>Cache first, falling back to network；</li><li>Cache, with network update；</li><li>Network only；</li><li>Network first, falling back to cache</li></ul><p>策略详情以及 <a href="https://developers.google.com/web/tools/workbox/overview#the_technology_behind_workbox" target="_blank" rel="noopener">API 可参考文档</a> 这里不再赘述。</p><p>workbox 底层整合了sw-precache ， sw-toolbox 等工具，对于熟悉这些工具的同学，理解接口和排查问题时应该会轻松些。</p><h3 id="结合专属海报"><a href="#结合专属海报" class="headerlink" title="结合专属海报"></a>结合专属海报</h3><p>从<a href="/2017/09/让webapp的UI体验更接近原生的小技巧/">上一篇文章</a>可以看出，专属海报属于小型网页应用，本身没有很复杂的构建过程，所以我选择gulp作为构建工具。</p><p>专属海报实现离线化，其资源可分为三类：</p><p>1、应用自身逻辑和样式资源做预缓存（precaching）：在页面加载完成后就缓存到 Cache Storage，之后除非部署新版，都将从缓存读取资源</p><p><img src="http://wx3.sinaimg.cn/mw690/4d6e3e3bgy1fn0zd1rzz6j21kw0kldmf.jpg" alt="pwa"></p><p>2、cdn库文件使用运行时缓存（runtime caching），读取时采用缓存优先（cache first）策略：使用到到时候从网络加载，第二次起从缓存加载</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">urlPattern </span>: <span class="string">'https://vendor-Url/(.*)'</span>,</span><br><span class="line">    <span class="attribute">handler</span>: <span class="string">'cacheFirst'</span>,</span><br><span class="line">    <span class="attribute">options</span>: &#123;</span><br><span class="line">      <span class="attribute">cacheableResponse</span>: &#123;</span><br><span class="line">        <span class="attribute">statuses</span>: [<span class="number">0</span>, <span class="number">200</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attribute">urlPattern </span>: <span class="string">'https://CDN-Url/(.*)'</span>,</span><br><span class="line">    <span class="attribute">handler</span>: <span class="string">'cacheFirst'</span>,</span><br><span class="line">    <span class="attribute">options</span>: &#123;</span><br><span class="line">      <span class="attribute">cacheableResponse</span>: &#123;</span><br><span class="line">        <span class="attribute">statuses</span>: [<span class="number">0</span>, <span class="number">200</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3、请求接口的数据使用运行时缓存（runtime caching），网络优先策略（network first）：优先通过网络读取，断网后从缓存读取，用于实现离线浏览（不可提交）</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">urlPattern </span>: <span class="string">'https://API-Url/(.*)'</span>,</span><br><span class="line">    <span class="attribute">handler</span>: <span class="string">'networkFirst'</span>,</span><br><span class="line">    <span class="attribute">options</span>: &#123;</span><br><span class="line">      <span class="attribute">cacheableResponse</span>: &#123;</span><br><span class="line">        <span class="attribute">statuses</span>: [<span class="number">0</span>, <span class="number">200</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>完整的 gulp task 可<a href="https://gist.github.com/kainy/a40cfea1a514ef0e789a1943eb03d0ee" target="_blank" rel="noopener">参考配置</a></p><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>对于更加复杂的项目，可能 workbox 提供的缓存策略无法满足你的需求，这就需要自己定制一些路由逻辑。</p><p>对于复杂的<em>全新项目</em>，则可以考虑直接拿 lavas 生成脚手架，降低初始成本，不过感觉后续遇到问题，这些“省”下的时间还是要还回来的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>专属海报在开发中期就已接入 workbox1.X，但考虑到项目自身还未进入稳定状态，另一方面技术规范和客户端支持程度也不确定，而且缺乏效果监控方法。综合考虑收益和风险点，一直未在生产环境启用此特性，而目前随着 iOS 的支持和技术逐渐成熟，项目接入 PWA 的时机将趋近成熟。</p><p>将新技术引入实际项目后，理论上应该解决的问题是否如预期得到解决，解决效果如何？下一篇将介绍通过在服务端定期记录 Lighthouse 跑分结果，来度量优化效果的一些思考。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developers.google.com/web/tools/workbox" target="_blank" rel="noopener">Google 开发者网站</a></p><p><a href="ttps://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa" target="_blank" rel="noopener">饿了么的 PWA 升级实践</a></p><p><a href="http://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop" target="_blank" rel="noopener">借助Service Worker和cacheStorage缓存及离线开发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义问题&quot;&gt;&lt;a href=&quot;#定义问题&quot; class=&quot;headerlink&quot; title=&quot;定义问题&quot;&gt;&lt;/a&gt;定义问题&lt;/h3&gt;&lt;p&gt;由于业务发展&lt;/p&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="微海报" scheme="https://blogs.kainy.cn/tags/%E5%BE%AE%E6%B5%B7%E6%8A%A5/"/>
    
      <category term="图片" scheme="https://blogs.kainy.cn/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="优化" scheme="https://blogs.kainy.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="技术" scheme="https://blogs.kainy.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>通过小程序卡片打开APP获取参数的方法</title>
    <link href="https://blogs.kainy.cn/2018/02/%E9%80%9A%E8%BF%87%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%A1%E7%89%87%E6%89%93%E5%BC%80APP%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://blogs.kainy.cn/2018/02/通过小程序卡片打开APP获取参数的方法/</id>
    <published>2018-02-02T10:50:35.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>最近在研究小程序与 APP 互为补充，在营销业务中适用的场景。其中一个是 APP 中分享小程序卡片给微信好友，好友打开小程序卡片，参与活动后，跳回到 APP 中查看奖励或更多活动。</p><p>网上参考资料不多，请教了对这块比较了解的相关人士，记录一个。</p><a id="more"></a><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ul><li>APP 和小程序绑定同一个认证的开放平台账号</li><li>APP <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417694084&amp;token=7d65e489934a1bbe18bb7036d7c504af987fc7b5&amp;lang=zh_CN" target="_blank" rel="noopener">接入微信终端 SDK</a></li></ul><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p>通过 <code>open-type</code> 属性值设置为 <code>launchApp</code> 的 <code>&lt;button&gt;</code> 组件。</p><p>设置 <code>app-parameter</code> 传递的参数，</p><p>在我们的 APP 中可以通过 <code>onReq:(BaseReq*)reqonReq</code> 方法接收到 <code>req</code> 参数的 <code>req.message.messageExt</code> 获取到。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)onReq:(BaseReq *)req &#123;</span><br><span class="line">    WXMediaMessage *msg = req.message;</span><br><span class="line">    <span class="comment">//从微信启动App</span></span><br><span class="line">    <span class="built_in">NSString</span> *strMsg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"openID: %@, messageExt:%@"</span>, req.openID, msg.messageExt];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, strMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p><img src="https://wx3.sinaimg.cn/mw690/4d6e3e3bgy1fo2ifdb9enj20ku11276w.jpg" alt="微信小程序卡片打开 APP"></p><p><img src="https://wx3.sinaimg.cn/mw690/4d6e3e3bgy1fo2ifc78xzj20ku1120uc.jpg" alt="APP 接收来自小程序通过 app-parameter 属性配置的参数"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h3&gt;&lt;p&gt;最近在研究小程序与 APP 互为补充，在营销业务中适用的场景。其中一个是 APP 中分享小程序卡片给微信好友，好友打开小程序卡片，参与活动后，跳回到 APP 中查看奖励或更多活动。&lt;/p&gt;&lt;p&gt;网上参考资料不多，请教了对这块比较了解的相关人士，记录一个。&lt;/p&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="小程序" scheme="https://blogs.kainy.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="开发" scheme="https://blogs.kainy.cn/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="APP" scheme="https://blogs.kainy.cn/tags/APP/"/>
    
  </entry>
  
  <entry>
    <title>WebApp实现离线化</title>
    <link href="https://blogs.kainy.cn/2017/12/PWA%E5%9C%A8%E4%B8%93%E5%B1%9E%E6%B5%B7%E6%8A%A5%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://blogs.kainy.cn/2017/12/PWA在专属海报的应用/</id>
    <published>2017-12-25T10:50:35.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>PWA（渐进式网页应用）对于关注新技术得同学想必已不陌生。14年至今，其应用不如应有的那么广泛，最大的障碍：缺乏iOS支持，最近已被打破 —— <a href="https://juejin.im/post/5a3b357e6fb9a045104aa7b6" target="_blank" rel="noopener">Safari技术预览版已经默认开启 Service Worker</a>；</p><p>从开发者角度，缺少一个开箱即用的方案，且规范本身在快速发展，则是技术人员选择观望的重要原因。本文将以专属海报为例，介绍通过 workbox工具， 快速为项目启用 PWA 中离线特性的方法，以及技巧总结。</p><a id="more"></a><h3 id="workbox介绍"><a href="#workbox介绍" class="headerlink" title="workbox介绍"></a>workbox介绍</h3><p>workbox 是用来实现网页应用离线化的构建工具，通过生成的 service worker 文件，让你的离线静态资源管理策略得以在用户端实现。由于 service worker 本身是飞速发展规范，且客户端支持程度不一，通过调用 workerbox 的 API，可以最大程度的屏蔽这些兼容问题，从这个方面理解，有点像 jQuery 在 ie 时代的作用，差别是前者解决的是 service work 运行环境的兼容性问题，而 jQuery 解决的事浏览器兼容性问题。</p><p>workbox 本身集成了常用的五套缓存策略</p><ul><li>Cache only；</li><li>Cache first, falling back to network；</li><li>Cache, with network update；</li><li>Network only；</li><li>Network first, falling back to cache</li></ul><p>策略详情以及 <a href="https://developers.google.com/web/tools/workbox/overview#the_technology_behind_workbox" target="_blank" rel="noopener">API 可参考文档</a> 这里不再赘述。</p><p>workbox 底层整合了sw-precache ， sw-toolbox 等工具，对于熟悉这些工具的同学，理解接口和排查问题时应该会轻松些。</p><h3 id="结合专属海报"><a href="#结合专属海报" class="headerlink" title="结合专属海报"></a>结合专属海报</h3><p>从<a href="/2017/09/让webapp的UI体验更接近原生的小技巧/">上一篇文章</a>可以看出，专属海报属于小型网页应用，本身没有很复杂的构建过程，所以我选择gulp作为构建工具。</p><p>专属海报实现离线化，其资源可分为三类：</p><p>1、应用自身逻辑和样式资源做预缓存（precaching）：在页面加载完成后就缓存到 Cache Storage，之后除非部署新版，都将从缓存读取资源</p><p><img src="http://wx3.sinaimg.cn/mw690/4d6e3e3bgy1fn0zd1rzz6j21kw0kldmf.jpg" alt="pwa"></p><p>2、cdn库文件使用运行时缓存（runtime caching），读取时采用缓存优先（cache first）策略：使用到到时候从网络加载，第二次起从缓存加载</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">urlPattern </span>: <span class="string">'https://vendor-Url/(.*)'</span>,</span><br><span class="line">    <span class="attribute">handler</span>: <span class="string">'cacheFirst'</span>,</span><br><span class="line">    <span class="attribute">options</span>: &#123;</span><br><span class="line">      <span class="attribute">cacheableResponse</span>: &#123;</span><br><span class="line">        <span class="attribute">statuses</span>: [<span class="number">0</span>, <span class="number">200</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attribute">urlPattern </span>: <span class="string">'https://CDN-Url/(.*)'</span>,</span><br><span class="line">    <span class="attribute">handler</span>: <span class="string">'cacheFirst'</span>,</span><br><span class="line">    <span class="attribute">options</span>: &#123;</span><br><span class="line">      <span class="attribute">cacheableResponse</span>: &#123;</span><br><span class="line">        <span class="attribute">statuses</span>: [<span class="number">0</span>, <span class="number">200</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3、请求接口的数据使用运行时缓存（runtime caching），网络优先策略（network first）：优先通过网络读取，断网后从缓存读取，用于实现离线浏览（不可提交）</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">urlPattern </span>: <span class="string">'https://API-Url/(.*)'</span>,</span><br><span class="line">    <span class="attribute">handler</span>: <span class="string">'networkFirst'</span>,</span><br><span class="line">    <span class="attribute">options</span>: &#123;</span><br><span class="line">      <span class="attribute">cacheableResponse</span>: &#123;</span><br><span class="line">        <span class="attribute">statuses</span>: [<span class="number">0</span>, <span class="number">200</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>完整的 gulp task 可<a href="https://gist.github.com/kainy/a40cfea1a514ef0e789a1943eb03d0ee" target="_blank" rel="noopener">参考配置</a></p><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>对于更加复杂的项目，可能 workbox 提供的缓存策略无法满足你的需求，这就需要自己定制一些路由逻辑。</p><p>对于复杂的<em>全新项目</em>，则可以考虑直接拿 lavas 生成脚手架，降低初始成本，不过感觉后续遇到问题，这些“省”下的时间还是要还回来的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>专属海报在开发中期就已接入 workbox1.X，但考虑到项目自身还未进入稳定状态，另一方面技术规范和客户端支持程度也不确定，而且缺乏效果监控方法。综合考虑收益和风险点，一直未在生产环境启用此特性，而目前随着 iOS 的支持和技术逐渐成熟，项目接入 PWA 的时机将趋近成熟。</p><p>将新技术引入实际项目后，理论上应该解决的问题是否如预期得到解决，解决效果如何？下一篇将介绍通过在服务端定期记录 Lighthouse 跑分结果，来度量优化效果的一些思考。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developers.google.com/web/tools/workbox" target="_blank" rel="noopener">Google 开发者网站</a></p><p><a href="ttps://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa" target="_blank" rel="noopener">饿了么的 PWA 升级实践</a></p><p><a href="http://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop" target="_blank" rel="noopener">借助Service Worker和cacheStorage缓存及离线开发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h3&gt;&lt;p&gt;PWA（渐进式网页应用）对于关注新技术得同学想必已不陌生。14年至今，其应用不如应有的那么广泛，最大的障碍：缺乏iOS支持，最近已被打破 —— &lt;a href=&quot;https://juejin.im/post/5a3b357e6fb9a045104aa7b6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Safari技术预览版已经默认开启 Service Worker&lt;/a&gt;；&lt;/p&gt;&lt;p&gt;从开发者角度，缺少一个开箱即用的方案，且规范本身在快速发展，则是技术人员选择观望的重要原因。本文将以专属海报为例，介绍通过 workbox工具， 快速为项目启用 PWA 中离线特性的方法，以及技巧总结。&lt;/p&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="web" scheme="https://blogs.kainy.cn/tags/web/"/>
    
      <category term="技术" scheme="https://blogs.kainy.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="PWA" scheme="https://blogs.kainy.cn/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>让webapp的UI体验更接近原生的小技巧</title>
    <link href="https://blogs.kainy.cn/2017/09/%E8%AE%A9webapp%E7%9A%84UI%E4%BD%93%E9%AA%8C%E6%9B%B4%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%94%9F%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://blogs.kainy.cn/2017/09/让webapp的UI体验更接近原生的小技巧/</id>
    <published>2017-09-15T10:50:35.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>下拉刷新（图2）和长按选中（图3）是移动端常用操作，也是区分 APP 原生页面和 H5 页面最直观的方法（图1）之一。</p><center><br><img src="https://wx1.sinaimg.cn/mw690/4d6e3e3bly9fjmajxjcchj20ku0n2doi.gif" alt="下拉刷新" width="282"><br><p><i>图1：被一眼看出的 H5 页面</i></p><br></center><a id="more"></a><center><br><img src="https://wx1.sinaimg.cn/mw690/4d6e3e3bgy1fj9xxylvyxg205h09u77b.gif" alt="下拉刷新" width="282"><br><p><i>图2：下拉刷新</i></p><br><br><img src="https://wx1.sinaimg.cn/large/4d6e3e3bgy1fj9xxzy9hyg205k09v12m.gif" alt="长按选中" width="282"><br><p><i>图3：长按选中</i></p><br></center><p>专属海报是一款重交互的网页应用，由于依赖阿拉丁（公司内部混合应用框架）提供的文件保存到系统相册和跨应用分享等能力，只允许在宿主 APP 中访问。从视频1可以看出，专属海报尤其依赖划动操作，而划动操作很容易误触发下拉回弹和长按选中事件，这些预期外的操作反馈会给用户注意力带来干扰，所以这里要蔽这两种交互形式带来的操作反馈 —— 既不能为我们所用，又会暴露了我们的身份（H5），就让我们愉快地把它们统统干掉吧。入了 native 的乡，就把自己安安静静地换上 native 的脸 😄</p><center><br><iframe frameborder="0" width="282" height="498" src="https://v.qq.com/iframe/player.html?vid=i05496p1vfh&tiny=1&auto=0&start=47" allowfullscreen></iframe><br><p><i>视频1：专属海报操作</i></p><br></center><h3 id="阻止下拉回弹"><a href="#阻止下拉回弹" class="headerlink" title="阻止下拉回弹"></a>阻止下拉回弹</h3><p>海报选择和全屏预览通过左右划动来实现，为避免划动海报列表完成选择图片操作动作时，在垂直方向的偏差(图4)导致页面整体上下摆动的交互反馈影响到用户关注的焦点，尤其在全屏预览状态中，如果出现上下白边就显得页面感十足／很山寨／“too naive”／“no native“ 😂，所以我们需要禁止页面拉到上下边界出现留白然后回弹的效果。</p><center><br><img src="https://wx1.sinaimg.cn/large/4d6e3e3bgy1fj9y1doojhj20jb05kjrn.jpg" alt="左右划动角度"><br><p><i>图4：划动角度偏差</i></p><br></center><p>可以通过为 body 添加 touchmove 属性来达到目的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ontouchmove</span>=<span class="string">event.preventDefault()</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在出现滚动界面或者需要监听 touchmove 事件的时候（视频中九宫格出现时），执行 js 语句切换开关：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用滚动</span></span><br><span class="line">$(<span class="built_in">document</span>.body).attr(<span class="string">'ontouchmove'</span>, <span class="string">''</span>);</span><br><span class="line"><span class="comment">// 禁用滚动</span></span><br><span class="line">$(<span class="built_in">document</span>.body).attr(<span class="string">'ontouchmove'</span>, <span class="string">'event.preventDefault()'</span>);</span><br></pre></td></tr></table></figure><h3 id="禁用长按选中"><a href="#禁用长按选中" class="headerlink" title="禁用长按选中"></a>禁用长按选中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*所有元素不可长按选中*/</span></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">-webkit-touch-callout</span>:none;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>:none;</span><br><span class="line">  <span class="attribute">-khtml-user-select</span>:none;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>:none;</span><br><span class="line">  <span class="attribute">-ms-user-select</span>:none;</span><br><span class="line">  <span class="attribute">user-select</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输入框可长按选中*/</span></span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">textarea</span>,</span><br><span class="line">*<span class="selector-attr">[contenteditable]</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-touch-callout</span>:initial;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: text;</span><br><span class="line">  <span class="attribute">-khtml-user-select</span>: text;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>: text;</span><br><span class="line">  <span class="attribute">-ms-user-select</span>: text;</span><br><span class="line">  <span class="attribute">user-select</span>: text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>第一段 css 将所有元素长按选中，第二段 css 允许输入框中进行选中操作</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js 捕获菜单事件</span></span><br><span class="line"><span class="comment">// $ = Zepto</span></span><br><span class="line">$(<span class="built_in">document</span>.body).bind(<span class="string">'contextmenu'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log('contextmenu stoped', e.target);</span></span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><em>通过 js 监听菜单唤起事件并阻止。</em></p><p>也许相比热门的 React Native 等技术方案，这两个小技巧看起来了并不那么“酷”，但 RN 并不一定适合所有业务场景，比如开发验证性质的 webapp ，若因此要求重构 APP 来达到发挥新技术优势的目的，则未免削足适履。</p><p>相比以最低成本于解决实际问题、推进业务目标达成，所采用的技术是“酷”还是 “out” 也许并没想象中那么重要，从这个角度来看工程师的价值反而体现在能否 “Get Shit Done”。</p><p>这样处理了以后，在 UI 层面离原生体验就接近了一些。下一篇将介绍自己利用 Service Worker 实现离线访问的实践，更进一步地让这个 webapp 使用起来接近原生应用。虽然目前只有安卓版 APP 支持 Service Worker，但对于 iOS 版 APP 的用户即使暂时体验不到优化效果，却也能平稳降级，并不会因优化而带来副作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下拉刷新（图2）和长按选中（图3）是移动端常用操作，也是区分 APP 原生页面和 H5 页面最直观的方法（图1）之一。&lt;/p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw690/4d6e3e3bly9fjmajxjcchj20ku0n2doi.gif&quot; alt=&quot;下拉刷新&quot; width=&quot;282&quot;&gt;&lt;br&gt;&lt;p&gt;&lt;i&gt;图1：被一眼看出的 H5 页面&lt;/i&gt;&lt;/p&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="web" scheme="https://blogs.kainy.cn/tags/web/"/>
    
      <category term="native" scheme="https://blogs.kainy.cn/tags/native/"/>
    
      <category term="交互" scheme="https://blogs.kainy.cn/tags/%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>小程序页面“被缓存”问题的解决方法</title>
    <link href="https://blogs.kainy.cn/2017/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E2%80%9C%E4%B9%B1%E5%85%A5%E2%80%9D%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://blogs.kainy.cn/2017/09/小程序页面“乱入”问题的解决办法/</id>
    <published>2017-09-03T10:50:35.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到 caoz 在公众号文章《小程序的红利期》里提到</p><blockquote><p>“有时候进入小程序，会乱跳一些非目标页面，比如进入某人的语音红包，结果进入的是另一个人的”</p></blockquote><p>这个问题。自己曾今遇到并解决过，可至今仍能在一些颇具影响力的小程序上发现，似乎不少开发者都认定这是小程序的锅了，感觉有必要把这个问题拎出来说说。</p><a id="more"></a><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>如上所述，短时间内进出同一个小程序的不同链接，会打开前一次进入的页面，好像“页面被缓存”或者“数据被缓存”了导致”小程序页面乱入“。手动结束该小程序的后台进程（安卓）或重启微信（iOS、安卓）后，再打开才展示正确的页面。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>将页面 js 文件中 Page（）函数之外的变量都移到 Page（） 函数内。</p><p>具体到代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被“缓存”的状态</span></span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad (options) &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = option.a</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">// 移到这里</span></span><br><span class="line">  option: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad (options) &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="keyword">this</span>.option.a</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>小程序没有重启的概念，返回或者点击关闭操作时进入后台，会维持一段时间的运行状态（除非达到触发销毁的条件）。</p><p>再次打开的逻辑是<strong>清空页面栈</strong>进入指定页面，而如果此时小程序处于后台运行的状态，Page（）之外声明的变量并未被销毁，如果上一个页面注销前改动过，并且再次进入的页面访问到这个变量，就会把页面状态保持下来出现“页面乱入”的情况。而由于页面栈被清空，Page（）整个被销毁了，存在其中的状态也自然不存在了，这就是第二段代码的写法能问题解决的原理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>原理和解决方法并不复杂，理解了小程序的生命周期，也就好办了。所以开发文档前面的基础内容如“框架”部分还是有必要认真看完，切不可看懂“简易教程“就对着 API 文档开干哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到 caoz 在公众号文章《小程序的红利期》里提到&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“有时候进入小程序，会乱跳一些非目标页面，比如进入某人的语音红包，结果进入的是另一个人的”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个问题。自己曾今遇到并解决过，可至今仍能在一些颇具影响力的小程序上发现，似乎不少开发者都认定这是小程序的锅了，感觉有必要把这个问题拎出来说说。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://blogs.kainy.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="小程序" scheme="https://blogs.kainy.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="前端开发" scheme="https://blogs.kainy.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="页面缓存" scheme="https://blogs.kainy.cn/tags/%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>TFC2017参会速记</title>
    <link href="https://blogs.kainy.cn/2017/06/TFC2017%E5%8F%82%E4%BC%9A%E9%80%9F%E8%AE%B0/"/>
    <id>https://blogs.kainy.cn/2017/06/TFC2017参会速记/</id>
    <published>2017-06-24T09:58:02.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>大会开幕词中 Stone 提到的“技术半衰期”让人印象深刻，确实前端技术日新月异，要保持持续学习的能力和耐力。</p><p>第一个分享主题 Nicolas 介绍了 TC39 ，ECMAScript 规范产生流程的五个阶段，并介绍了目前处于 stage4 的 Async Functions 、 数组实例等 includes 方法; stage3 的 Async Iteration、Dynamic import（）等； stage2的 类装饰器、 promise 实例的 finally 方法等，让我们看到前端未来的发展方向。<br><a id="more"></a><br>第二个主题来自张云龙，介绍了组件的奋志细想、前端工程化的实践经验、以及看板式团队协作的优点，从宏观角度看前端。尤其对于 Gitlab 用来搭建持续集成和专属测试环境的经验分享令我很受启发，看得出这套方案确实解决了开发、测试流程中的共性问题，“全民”技术团队对工具灵活运用令人叹服，对比自身之前虽有过<a href="https://blogs.kainy.cn/2016/12/%E9%A1%B9%E7%9B%AE%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E8%B7%B5/">类似尝试</a>且实现方式相近，但最终停留在预研阶段，需反省在推动和执行能力上的差距。</p><p>第三个分享是来自迷渡的《面向前端开发者的 V8 性能优化》，从微观上刨析了 V8 性能优化的方法及原理，但由于涉及较为底层细节，且自身实际开发中解决大计算量导致 js 性能瓶颈的实践并不多，感觉没能理解很多，需要消化消化。</p><p>下午参加 NodeJS&amp;工程化 分会场，第一个分享来自贺老的《Start R&amp;B》介绍了 Ocaml 语言，以及使用 Renson 搭配 BuckleTypes ，实现“使用 Ocaml 的方式写 js 代码，并编译到 js”。结合之前在 jsConf2015 上的《JavaScript - The World’s Best Programming Language》和 中国前端开发者大会2016上 Elastic tabstops 的分享，贺老在我心目中 “语言大家” 的得到了形象进一步深化。</p><p>第二个分享来自郭润增的《微信支付大规模前端外包实战》，介绍了项目外包实践中遇到的挑战，以及通过技术和约定的手段实现“借力”和“赋能”，确保外包的工作达标验收且符合规范。其中提到的“消灭假充实”问题值得深思。</p><p>总的来说，大会内容从宏观和微观角度描绘了前端的发展现状和未来。可以看到前端模块化、组件化和工程化的日臻成熟完善，与客户端、服务端的边界进一步模糊而获得了更加极致的性能提升，并且与 AR／VR、AI 等新热技术的结合带来了更多的可能性，也对前端工程师提出了新的挑战。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大会开幕词中 Stone 提到的“技术半衰期”让人印象深刻，确实前端技术日新月异，要保持持续学习的能力和耐力。&lt;/p&gt;&lt;p&gt;第一个分享主题 Nicolas 介绍了 TC39 ，ECMAScript 规范产生流程的五个阶段，并介绍了目前处于 stage4 的 Async Functions 、 数组实例等 includes 方法; stage3 的 Async Iteration、Dynamic import（）等； stage2的 类装饰器、 promise 实例的 finally 方法等，让我们看到前端未来的发展方向。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://blogs.kainy.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="腾讯" scheme="https://blogs.kainy.cn/tags/%E8%85%BE%E8%AE%AF/"/>
    
      <category term="前端开发" scheme="https://blogs.kainy.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="大会" scheme="https://blogs.kainy.cn/tags/%E5%A4%A7%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>硅谷之行的收获</title>
    <link href="https://blogs.kainy.cn/2017/03/%E7%A1%85%E8%B0%B7%E4%B9%8B%E8%A1%8C%E7%9A%84%E6%94%B6%E8%8E%B7/"/>
    <id>https://blogs.kainy.cn/2017/03/硅谷之行的收获/</id>
    <published>2017-03-19T05:22:43.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天看到同行小伙伴都有所总结，我也匆匆撸了一篇（最后还是没忍住偷了点懒 😜 ，有种回到小学暑假最后几天赶作业的错觉。。</p><p>此次行程，博览老司机带我们参观了 Google、PayPal 这样的IT巨头，也拜访了 SkyMind 这样的初创企业，在泛伟律所以及孵化器 RocketSpace 听创业故事和法规案例，到斯坦福和旧金山大学感受学府气息，可以说行程囊括了硅谷科技生态中的方方面面。<br><a id="more"></a><br>就我个人而言最大的收获是世界观的完善 —— 透过上一个世界观，在技术方面，我也许该对见到的高科技玩意如自动驾驶、深度学习浓墨重彩、津津乐道；在意识形态方面，对美国司机的礼让赞不绝口。</p><p>但仔细想想，这不都是去之前就从别人嘴里听说过的现象么？而现在则会进一步思考技术之外，新科技对法律和社会层面的影响。</p><p>拿两个完整生态的一部分做对比并无意义；完美世界本不存在，对周遭环境的埋怨，和对乌托邦的追捧，无益于发现自身不足和问题的解决。我们应该接受“为运行的火车换轮子”的现实，如果周遭万物、世界运行都如己所愿，那么人存在的意义又是什么呢。</p><p>此次行程的更多收获，同行的小伙伴们都有很赞的总结，感觉比我想写的更深刻、文彩也更好，我这里就偷个懒，不展开细说，直接引用啦。</p><ul><li><p>Tinyfool： <a href="http://mp.weixin.qq.com/s/xt4F19ePjzvdORGerVQ2zQ" target="_blank" rel="noopener">无人驾驶汽车、硅谷生活和计算机博物馆</a></p></li><li><p>唐巧： <a href="http://mp.weixin.qq.com/s/zzj9KKGTup4wwm0fyZhMSw" target="_blank" rel="noopener">​硅谷之行（一）- 惊喜和落差</a></p></li><li><p>Shelly： <a href="http://www.jianshu.com/p/882ac92b0e6f?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-timeline&amp;from=timeline" target="_blank" rel="noopener">飘洋过海来看你 —美国硅谷行记</a></p></li><li><p>VAYY： <a href="http://www.jianshu.com/p/472e6da0a4fd" target="_blank" rel="noopener">我的硅谷之旅</a></p></li><li><p>以及谢工前辈在自己参与打造的产品 GitChat 上发起的讨论： <a href="http://gitbook.cn/m/mazi/activity/58c63846a870add761c59098?bogot=ka1Ju9&amp;from=singlemessage" target="_blank" rel="noopener">探究创新的真谛：硅谷之行的8个精彩瞬间</a></p></li></ul><p>最后是我在本次行程中的行行摄摄，照片没有做特别整理，可以比较完整的还原个人视角。由于微信还不支持长按二维码打开小程序，需要使用另外一部手机，通过扫一扫浏览 😅（听说内测版本6.4.6支持了，有兴趣的可以试试</p><p><img src="http://wx1.sinaimg.cn/mw690/4d6e3e3bly1fdmd8k9dpuj20d20evdh2.jpg" alt="硅谷行收获 —— 跨时空"> 图片配文持续补充中… （神啊，救救这位懒癌患者吧。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天看到同行小伙伴都有所总结，我也匆匆撸了一篇（最后还是没忍住偷了点懒 😜 ，有种回到小学暑假最后几天赶作业的错觉。。&lt;/p&gt;&lt;p&gt;此次行程，博览老司机带我们参观了 Google、PayPal 这样的IT巨头，也拜访了 SkyMind 这样的初创企业，在泛伟律所以及孵化器 RocketSpace 听创业故事和法规案例，到斯坦福和旧金山大学感受学府气息，可以说行程囊括了硅谷科技生态中的方方面面。&lt;br&gt;
    
    </summary>
    
      <category term="心路历程" scheme="https://blogs.kainy.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
    
      <category term="硅谷" scheme="https://blogs.kainy.cn/tags/%E7%A1%85%E8%B0%B7/"/>
    
      <category term="创新" scheme="https://blogs.kainy.cn/tags/%E5%88%9B%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>小程序自定义分析功能（上）</title>
    <link href="https://blogs.kainy.cn/2017/02/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E6%9E%90%E5%8A%9F%E8%83%BD/"/>
    <id>https://blogs.kainy.cn/2017/02/小程序数据自定义分析功能/</id>
    <published>2017-02-10T07:33:16.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前为止，小程序后台的 “数据分析” 模块由 “实时统计” 和” 访问分析” 两部分组成，主要根据页面和时长两个维度来观察小程序受访情况，如详情页访问次数、时长、分享次数等等。但由于用户实际交互的小程序界面，由页面（page）和数据（appData）两部分组合而成，想要完成完整的用户行为分析，如访问者的地域、年龄、性别分布如何？不同用户群感兴趣的内容有何差异？具体到某一篇游记的浏览量如何？从浏览到分享的转化率如何？这些目标通过目前已有的标准统计是无法达到的。而自定义分析的推出恰恰解决了这些痛点。</p><h2 id="自定义分析功能牛逼之处"><a href="#自定义分析功能牛逼之处" class="headerlink" title="自定义分析功能牛逼之处"></a>自定义分析功能牛逼之处</h2><p>官方对自定义分析的描述是：</p><p>“自定义分析支持灵活多维和近实时的用户行为分析，可以通过自定义上报，对用户在小程序内的行为做精细化跟踪，满足页面访问等标准统计以外的个性化分析需求”</p><a id="more"></a><p>总结一句话就是更灵活、更精细化用来满足个性化分析需求的数据分析工具。既然是数据分析，就少不了配置上报，收集数据的步骤，不然哪来的数据供后续分析呢？与以往的 Webtrends、Google Analytics、百度统计… 的事件分析要求引入一个脚本，然后在页面中加入标记（埋点）的做法不同，这里采用一种无入侵的方式：只需在公众平台一处进行配置，而无需修改程序代码。比如点击事件，只需在事件配置页提供点击元素的 class（或ID）选择器即可。这种将修改统计配置，与代码逻辑解耦的好处是，市场／运营人员更改统计规则无需等待发版的时间窗口，而开发人员也不再抱怨代码里散落的埋点信息影响阅读、甚至编程逻辑。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>“纸上得来” 不如 “举个栗子”，这里以自己目前在运营的一个旅行日记小程序《跨时空》为例。前段时间在详情页加了个”回到首页”的小 icon ，想要提高通过分享链接进入详情页用户的留存率（由于小程序目前没有提供全局导航菜单，如果没有这个 icon，这部分用户浏览完页面就只能退出《跨时空》流失了），现在根据进入详情页（依据路径“／pages／trip／trip”和 编码或标题确定）的用户数和点击 icon（类名为”.home-nav”的按钮）次数统计即可，配置截图：</p><p><img src="//wx1.sinaimg.cn/mw690/4d6e3e3bgy1fcnrz0kxs6j21hs11mjve.jpg" alt="小程序自定义分析功能-click事件配置"></p><p><img src="//wx2.sinaimg.cn/mw690/4d6e3e3bgy1fcnrz0pitzj21hg0ts0uy.jpg" alt="小程序自定义分析功能-配置的测试"></p><p>另外对于营销活动，我们可能会关注具体某个活动（page+id）的分享情况，而不是整体（page）分享情况，通过原有的“访问页面”统计，我们只能看到页面整体的分享人／次数据：</p><p><img src="//wx1.sinaimg.cn/mw690/4d6e3e3bgy1fcnrz3mwtnj20o10chgmp.jpg" alt="小程序数据统计-访问页面"></p><p>而自定义分析，则可以实现具体到某篇游记的统计，配置截图：</p><p><img src="//wx1.sinaimg.cn/mw690/4d6e3e3bgy1fcns4h547wj21hc16yaf2.jpg" alt="小程序自定义分析功能-share事件配置"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于还在内测阶段，文档更新还稍有滞后，如trigger（触发条件）的含义说明，目前还漏了 pageLoad 和 pageUnload 对于非小程序开发者而言可能还无法区分和 engerPage／leavePage 之间的差异。</p><p><img src="//wx1.sinaimg.cn/mw690/4d6e3e3bgy1fcnrz39c04j216k0n841g.jpg" alt="小程序自定义分析功能文档"></p><p>但无论如何，个人认为自定义统计的上线，无疑是小程序发展历程中的重要一步。</p><p>由于刚完成事件发布步骤，还需要等待数据收集才能实践事件分析功能，统计和分析部分的内测评论将在下一篇进行分享，敬请期待。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前为止，小程序后台的 “数据分析” 模块由 “实时统计” 和” 访问分析” 两部分组成，主要根据页面和时长两个维度来观察小程序受访情况，如详情页访问次数、时长、分享次数等等。但由于用户实际交互的小程序界面，由页面（page）和数据（appData）两部分组合而成，想要完成完整的用户行为分析，如访问者的地域、年龄、性别分布如何？不同用户群感兴趣的内容有何差异？具体到某一篇游记的浏览量如何？从浏览到分享的转化率如何？这些目标通过目前已有的标准统计是无法达到的。而自定义分析的推出恰恰解决了这些痛点。&lt;/p&gt;&lt;h2 id=&quot;自定义分析功能牛逼之处&quot;&gt;&lt;a href=&quot;#自定义分析功能牛逼之处&quot; class=&quot;headerlink&quot; title=&quot;自定义分析功能牛逼之处&quot;&gt;&lt;/a&gt;自定义分析功能牛逼之处&lt;/h2&gt;&lt;p&gt;官方对自定义分析的描述是：&lt;/p&gt;&lt;p&gt;“自定义分析支持灵活多维和近实时的用户行为分析，可以通过自定义上报，对用户在小程序内的行为做精细化跟踪，满足页面访问等标准统计以外的个性化分析需求”&lt;/p&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="小程序" scheme="https://blogs.kainy.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="分析" scheme="https://blogs.kainy.cn/tags/%E5%88%86%E6%9E%90/"/>
    
      <category term="微信" scheme="https://blogs.kainy.cn/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="数据" scheme="https://blogs.kainy.cn/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="运营" scheme="https://blogs.kainy.cn/tags/%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>《跨时空》旅行日记小程序</title>
    <link href="https://blogs.kainy.cn/2017/01/%E3%80%8A%E8%B7%A8%E6%97%B6%E7%A9%BA%E3%80%8B%E6%97%85%E8%A1%8C%E6%97%A5%E8%AE%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>https://blogs.kainy.cn/2017/01/《跨时空》旅行日记小程序/</id>
    <published>2017-01-08T07:33:16.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>我喜欢旅行，在正文开始前，先向有共同兴趣的朋友推荐一个自己每次出行前必装的 APP —— 面包旅行。我主要用它来做旅行日志，每天行程结束，我都会将当天拍的照片上传并做简单的文字记录，记录是回顾一天行程的最好方式，也方便日后回忆。由于面包旅行的旅行日记基于旅行爱好者分享（UGC），相对比较纯粹，我平时还会在上面浏览旅记，常常能在不经意间找到打动自己的图片或文字。</p><a id="more"></a><h2 id="小程序由来"><a href="#小程序由来" class="headerlink" title="小程序由来"></a>小程序由来</h2><p>但后来发现，APP 的记录和浏览两部分功能，应用场景分别是旅行中和非旅行中。而对于和我一样的大多数普通人，大部分时间并不是在旅途中，而是在工作、生活里。也就是说，这个 APP 我同一时间点几乎只会用到一半的功能。于是我就在想会不会有一天官方把两部分功能独立成两个 APP ，但这件事至今没有发生。小程序的出现让我想起了这个心结，“一个小程序只做一件事”、”无需安装，用完即走“的理念不正是为此量身定制么？大部分时间里我想要的无非是在排队或等车的碎片时间里，翻翻旅记消遣和排解一下，不需要消息推送的打扰，也不想一遍遍重复 APP loading 界面。</p><p>开发过程似乎并不艰辛（毕竟“我是我的产品经理”的感觉和面对工作任务完全是两码事），倒是多次审核被拒有些失落，从审核之严亦可见微信对小程序期望之高，不过这对于用户而言其实是好事。开发和审核展开说的话篇幅较大，后续可能单独拎出来说，这里主要介绍“跨时空”小程序的几个功能界面。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="首页：旅记推荐"><a href="#首页：旅记推荐" class="headerlink" title="首页：旅记推荐"></a>首页：旅记推荐</h3><p>首页是“推荐”旅记，从面包旅行随机拉取质量较高的旅行日记列表。适合漫无目的的浏览。每个 banner 背景图是旅记封面，还包含的标题、访次、作者昵称等基本信息；</p><p><a href="http://ww4.sinaimg.cn/large/4d6e3e3bgw1fbj4fkrykdj20ku112e81.jpg" target="_blank" rel="noopener"><br><img src="//ww4.sinaimg.cn/mw690/4d6e3e3bgw1fbj4fkrykdj20ku112e81.jpg" style="width:17rem" alt="跨时空小程序-首页"></a><br><a href="http://ww4.sinaimg.cn/large/4d6e3e3bgw1fbj4fmsr4rj20ku112b1c.jpg" target="_blank" rel="noopener"><br><img src="//ww4.sinaimg.cn/mw690/4d6e3e3bgw1fbj4fmsr4rj20ku112b1c.jpg" style="width:17rem" alt="跨时空小程序-旅记详情页"></a><br><a href="http://ww4.sinaimg.cn/large/4d6e3e3bgw1fbj4fo0r7gj20ku112tu3.jpg" target="_blank" rel="noopener"><br><img src="//ww4.sinaimg.cn/mw690/4d6e3e3bgw1fbj4fo0r7gj20ku112tu3.jpg" style="width:17rem" alt="跨时空小程序-卡片页"></a></p><p>点击查看旅记详情页，一篇旅记是由许多照片+配文的卡片所组成，标题边上是作者头像，点击可以进入个人主页。点击卡片则查看卡片的互动情况，类似朋友圈的点赞和评价数。</p><p>推荐模块的信息结构是：旅记列表 - 旅记 - 卡片</p><h3 id="发现：旅行地点分类"><a href="#发现：旅行地点分类" class="headerlink" title="发现：旅行地点分类"></a>发现：旅行地点分类</h3><p>首页底部第二个导航“发现”，这里按照地域和主题分类的旅行目的地列表。如果你对某个地点的旅记感兴趣，这里会是不错的去处。</p><p><a href="http://ww4.sinaimg.cn/large/4d6e3e3bgw1fbj4fqe3orj20ku112e81.jpg" target="_blank" rel="noopener"><br><img src="//ww4.sinaimg.cn/mw690/4d6e3e3bgw1fbj4fqe3orj20ku112e81.jpg" style="width:17rem" alt="跨时空小程序-‘发现’导航"></a><br><a href="http://ww4.sinaimg.cn/large/4d6e3e3bgw1fbj4fshn4fj20ku112hdt.jpg" target="_blank" rel="noopener"><br><img src="//ww4.sinaimg.cn/mw690/4d6e3e3bgw1fbj4fshn4fj20ku112hdt.jpg" style="width:17rem" alt="跨时空小程序-‘目的地’列表"></a><br><a href="http://ww4.sinaimg.cn/large/4d6e3e3bgw1fbj4fuuuwbj20ku112npd.jpg" target="_blank" rel="noopener"><br><img src="//ww4.sinaimg.cn/mw690/4d6e3e3bgw1fbj4fuuuwbj20ku112npd.jpg" style="width:17rem" alt="跨时空小程序-‘精品游记’列表"></a></p><p>点击方块进入”热门地点”，地点详情页还未完成，所以目前还只能查看到”旅行地点”列表。和“精品游记”列表中的旅记，这里和首页类似，只不过所有游记都是在指定旅行目的地发生的。</p><p>”发现”模块的信息结构：目的地列表 - 热门地点/旅行地点分类/精品游记</p><h3 id="我的：个人中心"><a href="#我的：个人中心" class="headerlink" title="我的：个人中心"></a>我的：个人中心</h3><p>以及第三个导航“我的”：这部分是最晚开发的，目前做了个任务列表，微信登陆后可保存和同步任务信息。</p><p><a href="http://ww4.sinaimg.cn/large/4d6e3e3bgw1fbj8blcr23j20ku112hdt.jpg" target="_blank" rel="noopener"><br><img src="//ww4.sinaimg.cn/mw690/4d6e3e3bgw1fbj8blcr23j20ku112hdt.jpg" style="width:17rem" alt="跨时空小程序-个人主页"></a><br><a href="http://ww4.sinaimg.cn/large/4d6e3e3bgw1fbj4flhistj20ku112k7u.jpg" target="_blank" rel="noopener"><br><img src="//ww4.sinaimg.cn/mw690/4d6e3e3bgw1fbj4flhistj20ku112k7u.jpg" style="width:17rem" alt="跨时空小程序-旅记详情页"></a><br><a href="http://ww4.sinaimg.cn/large/4d6e3e3bgw1fbj4fv6832j20jy0zk41o.jpg" target="_blank" rel="noopener"><br><img src="//ww4.sinaimg.cn/mw690/4d6e3e3bgw1fbj4fv6832j20jy0zk41o.jpg" style="width:17rem" alt="跨时空小程序-分享消息"></a></p><p>如果遇到喜欢的内容，还可以分享到聊天会话中，召唤小伙伴一起欣赏。如截图所示，目前小程序分享内容时会自动截取当前页面，作为分享链接的封面，这样接收到分享的人就可以很直观的了解到你所希望传递的信息啦。</p><h2 id="广召天下英雄"><a href="#广召天下英雄" class="headerlink" title="广召天下英雄"></a>广召天下英雄</h2><p>正如你所看到，目前“跨时空”还有许多待完善的细节和功能点。要知道目前实现的，还只是本人作为一名开发者所能想到的，而内容展现亦非小程序大施拳脚之地，结合小程序提供的 LBS 、线下扫码能力，将有无限可能待你我发掘。所以借此发个英雄贴【请谅解一名开发者的狗（kai）粮（yuan）情节 —— 觉的自己做的狗粮好吃，就一定要向全世界宣布制作方法】</p><p>对“跨时空”小程序感兴趣也希望一同改进的朋友：如果你有想法又懂编码，欢迎 <a href="https://github.com/FJUT/weapp-demo-breadtrip/fork" target="_blank" rel="noopener">fork</a> 和提 PR；对于有想法但不会编程的可以把想法和意见提到 <a href="https://github.com/FJUT/weapp-demo-breadtrip/issues" target="_blank" rel="noopener">issue</a>；对于纯粹热爱旅行、喜欢小程序的朋友，如果你认可我们所做的努力和付出，请点击右上角菜单按钮，将喜欢的旅记／卡片分享到志趣相投的微信群／好友 😁</p><p><img src="http://ww1.sinaimg.cn/large/4d6e3e3bgw1fbj9yz04isj209k0awdfw.jpg" alt="小程序二维码：请使用手机摄像头扫码"></p><p>洞天之外，你会发现原来别人是这样玩儿的。最后来扯扯“跨时空”名字的由来，其实还受近期看的两部电影《奇异博士》和《你的名字》启发，意在让小程序成为连接你与旅行者之间的结绳。透过图文，能够产生共鸣的地方，才是你真正向往旅行的地方。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题外话&quot;&gt;&lt;a href=&quot;#题外话&quot; class=&quot;headerlink&quot; title=&quot;题外话&quot;&gt;&lt;/a&gt;题外话&lt;/h2&gt;&lt;p&gt;我喜欢旅行，在正文开始前，先向有共同兴趣的朋友推荐一个自己每次出行前必装的 APP —— 面包旅行。我主要用它来做旅行日志，每天行程结束，我都会将当天拍的照片上传并做简单的文字记录，记录是回顾一天行程的最好方式，也方便日后回忆。由于面包旅行的旅行日记基于旅行爱好者分享（UGC），相对比较纯粹，我平时还会在上面浏览旅记，常常能在不经意间找到打动自己的图片或文字。&lt;/p&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="小程序" scheme="https://blogs.kainy.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="开发" scheme="https://blogs.kainy.cn/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信" scheme="https://blogs.kainy.cn/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 项目持续集成实践</title>
    <link href="https://blogs.kainy.cn/2016/12/%E9%A1%B9%E7%9B%AE%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E8%B7%B5/"/>
    <id>https://blogs.kainy.cn/2016/12/项目持续集成实践/</id>
    <published>2016-12-15T22:15:55.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端开发流程（ 语法检查、编译、重载）的自动化我们在工作中已经用得比较溜了，这篇文章主要介绍 Node.js 应用部署到服务端过程（编译、测试）的自动化。</p><p>这里以开源的 API Mock 系统 AMP 的部署为例（ <a href="https://mocks.leanapp.cn" target="_blank" rel="noopener">https://mocks.leanapp.cn</a> ），通过这套系统提供的 mock 服务，前端可以在接口定义完毕后就着手开发，与后端接口开发并行以提升项目整体效率。接口支持 CORS 跨域访问、支持 HTTPS 访问，为前端开发，尤其是移动端开发带来便利。<br><a id="more"></a></p><h2 id="实现的效果"><a href="#实现的效果" class="headerlink" title="实现的效果"></a>实现的效果</h2><p>本地开发代码，提交到 gitlab 的 master 分支后自动测试和编译，并将编译结果提交到可部署生产的 built 分支，需要的时候一键发布生产。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>这里用到 gitlab.com 提供的私有代码托管和 git-ci 服务，以及 leancloud 的云引擎。gitlab.com 提供的服务可以使用自己搭建的 gitlab 替换。提供与 leancloud 类似云引擎功能的网站，市面上也不少，这里因为其免费策略合理所以采用，拿它们举例适用性较广。</p><p>首先我们要在项目根目录添加 <code>gitlab-ci.yml</code> 文件，用于描述持续集成的过程，分三个阶段：</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>只需要执行 Node.js 应用的测试命令: <code>npm test</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>执行 Node.js 应用的构建命令: <code>npm run build</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">.</span> <span class="string">deploy.sh</span> <span class="comment"># 为了方便脚本执行上下文控制，我们将命令写到 deploy.sh 中</span></span><br></pre></td></tr></table></figure><p><code>deploy.sh</code> 脚本完成两件事：</p><ol><li>执行编译命令</li><li>push 编译代码到 built 分支</li></ol><p>完整配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitlab-ci.yml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span> <span class="attr">node:6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存安装后的 node_modules ，以加速下次构建</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  paths:</span> </span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">i</span> <span class="bullet">-D</span>    <span class="comment"># 所有任务执行前都会执行该脚本，用于安装所有依赖包 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 ‘build' 任务，描述构建任务的执行</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span>        <span class="comment"># 定义所属阶段</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span>   <span class="comment"># 需要运行的脚本</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">build</span>           <span class="comment"># 'build' 任务仅影响 'build' 分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 'test' 任务， 描述测试任务的执行</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span>         <span class="comment"># 定义所属阶段</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span>    <span class="comment"># 需要运行的脚本</span></span><br><span class="line"><span class="attr">  except:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span>          <span class="comment"># 'test' 任务影响除 'master' 分支之外的所有分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 'deploy' 任务， 完成构建和部署</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">.</span> <span class="string">deploy.sh</span>     <span class="comment"># 需要运行的脚本</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span>          <span class="comment"># 'deploy' 任务仅影响 'master' 分支</span></span><br></pre></td></tr></table></figure><p>由于测试任务由除 master 之外的分支的 push 触发，而部署任务完成后，将编译结果 push 到 built 分支。所以我们 push 到 master 后，会先执行部署任务，部署任务完成后，执行测试任务（如下图）</p><p><img src="https://ww1.sinaimg.cn/large/4d6e3e3bgw1fasnuyxbxij21do0myq8j.jpg" alt="push 操作触发部署、测试任务"></p><p>任务执行结果：</p><p><img src="https://ww1.sinaimg.cn/large/4d6e3e3bgw1fasnv43a3rj21dy0n6grg.jpg" alt="执行结果"></p><p>有了构建好的代码，就可以部署到 leancloud 了，部署前我们需要告诉 leancloud 代码库地址，并将 <code>deploy key</code> 信息保存到 gitlab 的项目配置中。这样以后 leancloud 就可以凭 <code>deploy key</code> 向 gitlab 库拉取代码。</p><p><img src="https://ww1.sinaimg.cn/large/4d6e3e3bgw1fasnvfto9rj21d00sc7bq.jpg" alt="在 leancloud 上的“常规设置“中填写代码库地址，并获取 `deploy key`"></p><p><img src="https://ww1.sinaimg.cn/large/4d6e3e3bgw1fasnv6vy7fj20ug0nk0yb.jpg" alt="在 gitlab 上项目的“Deploy Keys“中填写上一步获取的 `deploy key`"></p><p>两边信息配置完毕，就可以开始部署，在“部署”面版填写“分支或版本号“为 built 即可。</p><p><img src="https://ww1.sinaimg.cn/large/4d6e3e3bgw1fasnupddu7j20mu0oujuq.jpg" alt="在 leancloud 云引擎中选择 built 分支部署"></p><p>如果一切顺利，部署成功后就可以访问应用了。</p><p><img src="https://ww1.sinaimg.cn/large/4d6e3e3bgw1fasog9t4wxj21eu0z2qgs.jpg" alt="部署完成访问应用"></p><p><em>（请注意：<a href="https://mocks.leanapp.cn" target="_blank" rel="noopener">演示系统</a>虽然功能 ok，但是运行环境为 leancloud 免费版云引擎，配额受限，请 <strong>不要</strong> 在实际项目中使用， 请使用大师在内网环境部署的。）</em></p><h2 id="解决工作中场景中哪些痛点"><a href="#解决工作中场景中哪些痛点" class="headerlink" title="解决工作中场景中哪些痛点"></a>解决工作中场景中哪些痛点</h2><ol><li><p>无缝版本切换，实现“为跑道上飞驰的赛车更换零件”——在 leancloud 部署应用到生产环境的过程中发现一个有意思的细节，就是新版本构建出问题并不影响线上服务。大致过程类似于在一台新服务器上运行好版本代码，然后把流量从上运行上一版本代码的服务器切过来，在此之前会检测配置的端口是否正常相应请求，如果不是就终止切换，并提示发版失败，发版成功则把“旧版服务器”做存档，以供后续版本回退。有了这一机制，发版本就可以选择最适合业务的时机，而不是非要等到用户量最低的时候，“他好我也好” 😝</p></li><li><p>提前暴露编译配置的问题，实际项目中更改生产构建配置，往往改完当时验证没问题后就不太会留意，而等到真正发版前的一段时间项目文件变动可能产生预料外的问题，这时发现再解决就占用了本已紧张的发版时间，而且需要定位产生问题的代码，这问题在多人协作以及长周期的版本尤其突出。而引入持续集成后，每次 push 将会触发测试环节，在这里加上构建测试，通过测试结果即可及时发现问题并处理。</p></li><li><p>提升开发体验，将一部分消耗资源、重复的、机械性的任务如全量编译，交由持续集成服务器完成，以节约开发机资源，让开发者专注于开发而不受打断。能有空伸个懒腰，发发呆不再是奢求。</p></li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>探索“云计算”、”微服务”这些新热技术在前端开发领域的应用场景，对理解“小而美”产品（快速迭代、小步快跑的同时保持新集成特性的稳定输出）存在的基础（支撑点），有推导和借鉴意义。</p><p>短期内切换应用部署方案显然并不现实，但这并不构成拒绝拥抱变化的充分条件，毕竟技术的发展不因主观意愿而转移，而去中心化和原子化（把功能和服务内聚为模块）显然是日益突显的两个特征。实际上下半年组内在一些项目中切换 git 做版本管理，并将暴露的问题解决得七七八八已是一个不错的开端。</p><hr><p>“ 我觉得套路和扯皮救不了中（cheng）国（xu）人（yuan），但技术储备可以 ”</p><p><img src="https://ww1.sinaimg.cn/large/4d6e3e3bgw1fb1vq7qshuj218c18gwlb.jpg" alt="我没说过这句话——鲁迅">。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端开发流程（ 语法检查、编译、重载）的自动化我们在工作中已经用得比较溜了，这篇文章主要介绍 Node.js 应用部署到服务端过程（编译、测试）的自动化。&lt;/p&gt;&lt;p&gt;这里以开源的 API Mock 系统 AMP 的部署为例（ &lt;a href=&quot;https://mocks.leanapp.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mocks.leanapp.cn&lt;/a&gt; ），通过这套系统提供的 mock 服务，前端可以在接口定义完毕后就着手开发，与后端接口开发并行以提升项目整体效率。接口支持 CORS 跨域访问、支持 HTTPS 访问，为前端开发，尤其是移动端开发带来便利。&lt;br&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="持续集成" scheme="https://blogs.kainy.cn/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="实践" scheme="https://blogs.kainy.cn/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="Node.js" scheme="https://blogs.kainy.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>ATS ( App Transport Security )是什么，以及如何支持 ATS</title>
    <link href="https://blogs.kainy.cn/2016/12/ATS%20(%20App%20Transport%20Security%20)%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%20ATS/"/>
    <id>https://blogs.kainy.cn/2016/12/ATS ( App Transport Security )是什么，以及如何支持 ATS/</id>
    <published>2016-12-12T18:21:12.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天明秋童鞋在需求文档中看到接入任意门需要满足 ATS 标准，我们就来了解了下什么是 ATS ；该标准对 web 开发的影响，及应对措施。</p><h2 id="什么是-ATS"><a href="#什么是-ATS" class="headerlink" title="什么是 ATS"></a>什么是 ATS</h2><p>App Transport Security，简称 ATS，是苹果为了提高 App 与服务器之间数据安全，而在 iOS 9 当中首次推出的一项安全特性。在苹果全球开发者大会（WWDC）的一场演示中，该公司公布了一个最后期限——2017 年 1 月 1 日——即 App Store 当中的所有应用必须在这个日期之前启用这一重要安全功能。</p><a id="more"></a><p><img src="//ww2.sinaimg.cn/large/4d6e3e3bgw1faowh7bp4bj20s40f8dmb.jpg" alt="昨晚收到的新浪微博开放平台“催命邮件”"></p><p>距离最后期限越来越近，于是开发者们又将收到一波升级需求,不升级的后果图片里面说得比较清楚了。对应工作中的场景，就是版本因达不到接入标准而延期，这时候就不是走个特批就能解决的问题了，因为后面还有一道 App Store 上架的外部审核，要是卡在这里后果就是 App 无法如期上架，全员落水，运营和 iOS 开发哥哥提前表示 “这锅咱不背不背不背啊😭…”</p><p>所以今后如果不幸因 ATS 被“不达标”了，表觉得是 someone 有意怼你，应该明白这背后是一家伟大公司为了保护用户数据安全而做的充满情怀和正义感的事情，嗯 (认真脸)。</p><h2 id="ATS-的硬性指标："><a href="#ATS-的硬性指标：" class="headerlink" title="ATS 的硬性指标："></a>ATS 的硬性指标：</h2><ol><li>强制使用 https</li><li>证书域名和链接地址域名匹配</li><li>根证书受苹果信任</li><li>证书在有效期内</li><li>必须支持 TLS1.2</li><li>至少 RSA 2048位或者是 ECC 256位密钥加密</li><li>SHA256 算法证书</li><li>加密套件要求，必须使用 AES-128 或者 AES-256 支持，并且支持完整前向加密：</li></ol><p>RSA 算法要求使用以下加密套件：</p><blockquote><p>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384<br>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256<br>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384<br>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256<br>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</p></blockquote><p>DSA 算法要求使用以下加密套件：</p><blockquote><p>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384<br>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256<br>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384<br>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA<br>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256<br>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</p></blockquote><p>总结下就是：<strong>必须使用 https 协议；证书有效且强度足够</strong>。</p><h2 id="如何支持-ATS-标准"><a href="#如何支持-ATS-标准" class="headerlink" title="如何支持 ATS 标准"></a>如何支持 ATS 标准</h2><ol><li><p>强度足够的证书好解决，购买苹果信任CA所颁发的证书即可，一般知名的商业证书颁发机构如 GoDaddy 、 VeriSign …</p></li><li><p>然后就是部署 https 的 web 服务，这里以常见的 Nginx、Apache 以及 Tomcat 为参考：</p></li></ol><ul><li><p>2.1 Apache：（Apache，Nginx 要求关联的 openssl 版本在 1.0.1+ ，这样网站才支持 TLS1.2）</p><figure class="highlight apacheconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SSLProtocol</span>  <span class="literal">all</span> -SSLv2 -SSLv3</span><br><span class="line"><span class="attribute">SSLCipherSuite</span> ECDH:AESGCM:HIGH:!RC4:!DH:!MD5:!aNULL:!eNULL;</span><br></pre></td></tr></table></figure></li><li><p>2.2 Nginx</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>; </span><br><span class="line"><span class="attribute">ssl_ciphers</span> ECDH:AESGCM:HIGH:!RC4:!DH:!MD5:!aNULL:!eNULL;</span><br></pre></td></tr></table></figure></li><li><p>2.3 Tomcat 要求环境 tomcat7+ 和 JDK1.7+ ，配置参考如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"443"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11Protocol"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span> <span class="attr">scheme</span>=<span class="string">"https"</span> <span class="attr">secure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">keystoreFile</span>=<span class="string">"keystore/domain.jks"</span>  <span class="attr">keystorePass</span>=<span class="string">"证书密码"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">clientAuth</span>=<span class="string">"false"</span> <span class="attr">sslProtocol</span>=<span class="string">"TLS"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">ciphers</span>=<span class="string">"TLS_RSA_WITH_AES_128_GCM_SHA256,</span></span></span><br><span class="line"><span class="tag"><span class="string">                        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span></span></span><br><span class="line"><span class="tag"><span class="string">                        TLS_RSA_WITH_AES_128_CBC_SHA,</span></span></span><br><span class="line"><span class="tag"><span class="string">                        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,</span></span></span><br><span class="line"><span class="tag"><span class="string">                        TLS_RSA_WITH_AES_128_CBC_SHA256,</span></span></span><br><span class="line"><span class="tag"><span class="string">                        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,</span></span></span><br><span class="line"><span class="tag"><span class="string">                        SSL_RSA_WITH_3DES_EDE_CBC_SHA,</span></span></span><br><span class="line"><span class="tag"><span class="string">                        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>看到这里，你是不是该撸起袖子做些什么，或把本文转给需要它的运维童鞋们 ヽ(；▽；)ノ＼(^-^ ) 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天明秋童鞋在需求文档中看到接入任意门需要满足 ATS 标准，我们就来了解了下什么是 ATS ；该标准对 web 开发的影响，及应对措施。&lt;/p&gt;&lt;h2 id=&quot;什么是-ATS&quot;&gt;&lt;a href=&quot;#什么是-ATS&quot; class=&quot;headerlink&quot; title=&quot;什么是 ATS&quot;&gt;&lt;/a&gt;什么是 ATS&lt;/h2&gt;&lt;p&gt;App Transport Security，简称 ATS，是苹果为了提高 App 与服务器之间数据安全，而在 iOS 9 当中首次推出的一项安全特性。在苹果全球开发者大会（WWDC）的一场演示中，该公司公布了一个最后期限——2017 年 1 月 1 日——即 App Store 当中的所有应用必须在这个日期之前启用这一重要安全功能。&lt;/p&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>小程序金融保险行业应用交流</title>
    <link href="https://blogs.kainy.cn/2016/11/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%87%91%E8%9E%8D%E4%BF%9D%E9%99%A9%E8%A1%8C%E4%B8%9A%E5%BA%94%E7%94%A8%E4%BA%A4%E6%B5%81/"/>
    <id>https://blogs.kainy.cn/2016/11/小程序金融保险行业应用交流/</id>
    <published>2016-11-28T12:20:16.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二次渲染，暂不支持"><a href="#二次渲染，暂不支持" class="headerlink" title="二次渲染，暂不支持"></a>二次渲染，暂不支持</h3><ul><li>暂时用预设的 template 嵌套方案，后面几期做支持</li></ul><h3 id="crash-监控，版本回滚机制"><a href="#crash-监控，版本回滚机制" class="headerlink" title="crash 监控，版本回滚机制"></a>crash 监控，版本回滚机制</h3><ul><li>后续支持脚本错误，crash 信息，可能在 appjs 里捕获这些信息；</li><li>回滚暂时还是需要审核，应用发安卓市场还是 appstore 也都存在这个问题，质量把控，平台做再多的事情可能也不如开发者做得更好一些。</li></ul><a id="more"></a><h3 id="缓存在文件的数据防篡改"><a href="#缓存在文件的数据防篡改" class="headerlink" title="缓存在文件的数据防篡改"></a>缓存在文件的数据防篡改</h3><ul><li>底层机制：文件存放微信应用数据中，且每个小程序相互隔离；</li><li>保证了其他应用无法访问微信应用数据（除非root或越狱），小程序间无法互相篡改和访问</li></ul><h3 id="小程序的生命周期"><a href="#小程序的生命周期" class="headerlink" title="小程序的生命周期"></a>小程序的生命周期</h3><ul><li>小程序存活在微信的运行环境，</li><li>被销毁的情况一种情况是用户长时间没有操作，</li><li>还有一种是基于内存管理，如果用户开启更多的小程序，之前的小程序就可能被结束生命周期</li></ul><h3 id="c端用户进入小程序的方式"><a href="#c端用户进入小程序的方式" class="headerlink" title="c端用户进入小程序的方式"></a>c端用户进入小程序的方式</h3><ul><li>十二月初确定，会有一个固定的入口，会有一些分享的能力，后期慢慢会有发现的能力</li></ul><h3 id="（新金融研发）提交审核版本时候设置标签的限制。如何快速通过审核，如何更好的设置标签"><a href="#（新金融研发）提交审核版本时候设置标签的限制。如何快速通过审核，如何更好的设置标签" class="headerlink" title="（新金融研发）提交审核版本时候设置标签的限制。如何快速通过审核，如何更好的设置标签"></a>（新金融研发）提交审核版本时候设置标签的限制。如何快速通过审核，如何更好的设置标签</h3><ul><li>功能页面和标签、类目的设置一致，千万不要些和功能类目无关的标签（比如业务是外卖，就把点评、美团都堆砌上去）；</li><li>站在c端用户的角度去理解自己的产品，思考用户会使用哪些词来描述这个产品，标签的作用就是用户和小程序之间连接的桥梁</li></ul><h3 id="车险业务，能够提供什么样级别的用户分群的状况，比如说车险是不是能支持到微信用户是否车主？微信大概会拿出什么样的资源和大家一块做，这个可能会影响到业务方决定投入多少到这里面"><a href="#车险业务，能够提供什么样级别的用户分群的状况，比如说车险是不是能支持到微信用户是否车主？微信大概会拿出什么样的资源和大家一块做，这个可能会影响到业务方决定投入多少到这里面" class="headerlink" title="车险业务，能够提供什么样级别的用户分群的状况，比如说车险是不是能支持到微信用户是否车主？微信大概会拿出什么样的资源和大家一块做，这个可能会影响到业务方决定投入多少到这里面"></a>车险业务，能够提供什么样级别的用户分群的状况，比如说车险是不是能支持到微信用户是否车主？微信大概会拿出什么样的资源和大家一块做，这个可能会影响到业务方决定投入多少到这里面</h3><ul><li>数据这一块，用户画像会开放的比较慢，至多会提供一个群组，比如这一组人是什么标签，不会在用户没有授权的情况下透露用户的信息，这也是微信一只不敢做的事情；</li><li>在自己的阅历范围内，还没见过微信这么卖力的做一件事情，它会整合各个 BG（事业部） 资源，至少龙哥态度上是很支持这件事情的，会有每周一到两次的例会，具体来说：固定的入口，分享的能力，后面每件事情会比较谨慎，应该不会是爆发性的资源介入，而是一个过程，至于是怎么给，也只能说拭目以待。</li></ul><h3 id="教育类产品，每天推送模版消息让用户点击参与，希望将学习部分的功能迁移到小程序，但是小程序不支持主动推送"><a href="#教育类产品，每天推送模版消息让用户点击参与，希望将学习部分的功能迁移到小程序，但是小程序不支持主动推送" class="headerlink" title="教育类产品，每天推送模版消息让用户点击参与，希望将学习部分的功能迁移到小程序，但是小程序不支持主动推送"></a>教育类产品，每天推送模版消息让用户点击参与，希望将学习部分的功能迁移到小程序，但是小程序不支持主动推送</h3><ul><li>小程序本身对媒体类的服务不排斥，但是比较轻的媒体，还是建议做服务号，如果现有体系已经能够很好的满足。</li><li>小程序的目的是。公众号和小程序形态上是比较独立的，需要企业根据服务情况和偏好决定采用哪种，不会有强关联。</li></ul><h3 id="账号体系打通"><a href="#账号体系打通" class="headerlink" title="账号体系打通"></a>账号体系打通</h3><ul><li>unionid</li></ul><h3 id="实名信息，活体识别、视屏验证"><a href="#实名信息，活体识别、视屏验证" class="headerlink" title="实名信息，活体识别、视屏验证"></a>实名信息，活体识别、视屏验证</h3><ul><li>实名信息不会提供；可考虑使用视屏组件，截某几帧内容传到后台识别。如果现有能力不能够支持可以提需求。</li></ul><h3 id="保险营销很多是场景式嵌入，h5-嵌入到各个页面，但小程序是相互独立的"><a href="#保险营销很多是场景式嵌入，h5-嵌入到各个页面，但小程序是相互独立的" class="headerlink" title="保险营销很多是场景式嵌入，h5 嵌入到各个页面，但小程序是相互独立的"></a>保险营销很多是场景式嵌入，h5 嵌入到各个页面，但小程序是相互独立的</h3><ul><li>点对点合作，可能可以跳转限定数量的页面活小程序，已经提上日程，但要在小程序开放后的一段时间，预计是明年2、3月份</li></ul><h3 id="平安产险业务，1-车险每年快到期前三个月如何发提醒-2-模版消息发送-3-是否可以带参数-4-可否从公众号跳转小程序"><a href="#平安产险业务，1-车险每年快到期前三个月如何发提醒-2-模版消息发送-3-是否可以带参数-4-可否从公众号跳转小程序" class="headerlink" title="平安产险业务，1 车险每年快到期前三个月如何发提醒 2 模版消息发送 3 是否可以带参数 4 可否从公众号跳转小程序"></a>平安产险业务，1 车险每年快到期前三个月如何发提醒 2 模版消息发送 3 是否可以带参数 4 可否从公众号跳转小程序</h3><ul><li>前期不会放开公众号跳小程序；</li><li>独立的模版消息和公众号不太一样，不需要关注，只和是否页面互动有关；</li><li>一年后是否可发消息，暂无法预测；</li><li>参数可通过二维码传入</li></ul><h3 id="面向c端的入口什么时候开放；微信公众号和小程序之间的关系"><a href="#面向c端的入口什么时候开放；微信公众号和小程序之间的关系" class="headerlink" title="面向c端的入口什么时候开放；微信公众号和小程序之间的关系"></a>面向c端的入口什么时候开放；微信公众号和小程序之间的关系</h3><ul><li>个人觉得十二月份应该要落地，但还取决于客观因素，希望在发布是能囤积一些优秀案例；</li><li>关系和差别：<ul><li>龙哥之所以要做这件事，是因为觉得服务号没有把服务这件事做好，希望通过这套技术架构能够有个约束，真正做一些好的东西出来；</li><li>消息类，媒体这类消息类的东西还是适合在，页面形式的交互，还是适合在小程序上完成，后续会把以页面为主，消息为辅的功能在小程序这边做的更好些。</li></ul></li></ul><h3 id="绑定体验者的账号也要求绑卡，不方便测试；自定义”返回“按钮动作"><a href="#绑定体验者的账号也要求绑卡，不方便测试；自定义”返回“按钮动作" class="headerlink" title="绑定体验者的账号也要求绑卡，不方便测试；自定义”返回“按钮动作"></a>绑定体验者的账号也要求绑卡，不方便测试；自定义”返回“按钮动作</h3><ul><li>策略存在不合理的地方，后续考虑优化；</li><li>会考虑</li></ul><h3 id="（泰康在线）是否提供查询搜索关键字热词的接口，以便产品优化"><a href="#（泰康在线）是否提供查询搜索关键字热词的接口，以便产品优化" class="headerlink" title="（泰康在线）是否提供查询搜索关键字热词的接口，以便产品优化"></a>（泰康在线）是否提供查询搜索关键字热词的接口，以便产品优化</h3><ul><li>暂无计划，需要和搜索同事了解下。</li></ul><h3 id="提交审核时，走测试流程问题，保险产品购买受监管，重复购买会引起有关部门注意"><a href="#提交审核时，走测试流程问题，保险产品购买受监管，重复购买会引起有关部门注意" class="headerlink" title="提交审核时，走测试流程问题，保险产品购买受监管，重复购买会引起有关部门注意"></a>提交审核时，走测试流程问题，保险产品购买受监管，重复购买会引起有关部门注意</h3><ul><li>待研究</li></ul><h3 id="小程序模版消息发到哪里"><a href="#小程序模版消息发到哪里" class="headerlink" title="小程序模版消息发到哪里"></a>小程序模版消息发到哪里</h3><ul><li>对话界面“服务通知”，不是以账号维度发送</li></ul><h3 id="1M-尺寸的限制"><a href="#1M-尺寸的限制" class="headerlink" title="1M 尺寸的限制"></a>1M 尺寸的限制</h3><ul><li>几个方面：</li></ul><ol><li>小程序在移动网络中使用，希望做成轻量</li><li>目前看复杂的应用足够满足，图片资源用 cdn 纯文本 1M 是足够的</li></ol><h3 id="是否需要做设备适配"><a href="#是否需要做设备适配" class="headerlink" title="是否需要做设备适配"></a>是否需要做设备适配</h3><ul><li>不需要</li></ul><h3 id="是否会对小程序做推荐，比如提供分类排名"><a href="#是否会对小程序做推荐，比如提供分类排名" class="headerlink" title="是否会对小程序做推荐，比如提供分类排名"></a>是否会对小程序做推荐，比如提供分类排名</h3><ul><li>不会做推荐，分类排名还没有定</li></ul><h3 id="向日葵保险，是否支持多任务；是否可接入别的支付"><a href="#向日葵保险，是否支持多任务；是否可接入别的支付" class="headerlink" title="向日葵保险，是否支持多任务；是否可接入别的支付"></a>向日葵保险，是否支持多任务；是否可接入别的支付</h3><ul><li>支持多任务，可以切回聊天，小程序会在后台运行，按照堆栈顺序关闭使用频率最低的；</li><li>不会</li></ul><h3 id="搜索结果，是统一展示还是独立展示？"><a href="#搜索结果，是统一展示还是独立展示？" class="headerlink" title="搜索结果，是统一展示还是独立展示？"></a>搜索结果，是统一展示还是独立展示？</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二次渲染，暂不支持&quot;&gt;&lt;a href=&quot;#二次渲染，暂不支持&quot; class=&quot;headerlink&quot; title=&quot;二次渲染，暂不支持&quot;&gt;&lt;/a&gt;二次渲染，暂不支持&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;暂时用预设的 template 嵌套方案，后面几期做支持&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;crash-监控，版本回滚机制&quot;&gt;&lt;a href=&quot;#crash-监控，版本回滚机制&quot; class=&quot;headerlink&quot; title=&quot;crash 监控，版本回滚机制&quot;&gt;&lt;/a&gt;crash 监控，版本回滚机制&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;后续支持脚本错误，crash 信息，可能在 appjs 里捕获这些信息；&lt;/li&gt;&lt;li&gt;回滚暂时还是需要审核，应用发安卓市场还是 appstore 也都存在这个问题，质量把控，平台做再多的事情可能也不如开发者做得更好一些。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="小程序" scheme="https://blogs.kainy.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="金融" scheme="https://blogs.kainy.cn/tags/%E9%87%91%E8%9E%8D/"/>
    
      <category term="笔记" scheme="https://blogs.kainy.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>全栈工程师培训笔记</title>
    <link href="https://blogs.kainy.cn/2016/11/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    <id>https://blogs.kainy.cn/2016/11/全栈工程师培训笔记/</id>
    <published>2016-11-20T22:06:46.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>有幸参加阮一峰老师为期两天的《全栈工程师培训》，获益良多，将训练营四讲内容分享如下：</p><h2 id="纲要"><a href="#纲要" class="headerlink" title="纲要"></a>纲要</h2><h3 id="第一讲：前端开发的历史和趋势"><a href="#第一讲：前端开发的历史和趋势" class="headerlink" title="第一讲：前端开发的历史和趋势"></a>第一讲：<a href="http://github.kainy.cn/jstraining/history.html" target="_blank" rel="noopener">前端开发的历史和趋势</a></h3><ol><li>前端开发的历史演变</li><li>前端 MVC 框架的兴起</li><li>前后端分离</li><li>全栈工程师</li><li>前端开发的未来</li></ol><a id="more"></a><h3 id="第二讲：React-技术栈"><a href="#第二讲：React-技术栈" class="headerlink" title="第二讲：React 技术栈"></a>第二讲：<a href="http://github.kainy.cn/jstraining/react.html" target="_blank" rel="noopener">React 技术栈</a></h3><ol><li>React 的基本用法</li><li>React 应用的架构</li></ol><h3 id="第三讲：Node-应用开发"><a href="#第三讲：Node-应用开发" class="headerlink" title="第三讲：Node 应用开发"></a>第三讲：<a href="http://github.kainy.cn/jstraining/node.html" target="_blank" rel="noopener">Node 应用开发</a></h3><ol><li>Node 的基本用法</li><li>Restful API</li><li>Express 框架搭建 Web 应用</li></ol><h3 id="第四讲：前端工程简介"><a href="#第四讲：前端工程简介" class="headerlink" title="第四讲：前端工程简介"></a>第四讲：<a href="http://github.kainy.cn/jstraining/engineering.html" target="_blank" rel="noopener">前端工程简介</a></h3><ol><li>持续集成</li><li>静态代码检查</li><li>单元测试</li><li>功能测试</li><li>持续集成服务 Travis CI</li></ol><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>就我个人而言，收获比较大的是第三讲和第四讲内容，因为实际开发工作中涉及服务端开发和测试、集成方面较少，阮老师的讲解还是让自己开了眼界。</p><p>周末就花了些时间，使用 CircleCI 实践了一把持续集成，结合 <a href="https://github.com/gnab/remark" target="_blank" rel="noopener">remarkjs</a> 实现将阮老师的培训讲义（MarkDown格式），自动转为网页屁屁踢(见上文中的链接)，这样在讲义不断完善的过程中，文中的 PPT 内容也能保持更新，下一步的计划是把团队博客也这么整整，完了小伙伴们直接提交 md 即可，编译和发布过程都将自动集成 ( •̀ ω •́ )y 。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>感谢公司提供这么好的机会，能与技术大牛面对面学习交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有幸参加阮一峰老师为期两天的《全栈工程师培训》，获益良多，将训练营四讲内容分享如下：&lt;/p&gt;&lt;h2 id=&quot;纲要&quot;&gt;&lt;a href=&quot;#纲要&quot; class=&quot;headerlink&quot; title=&quot;纲要&quot;&gt;&lt;/a&gt;纲要&lt;/h2&gt;&lt;h3 id=&quot;第一讲：前端开发的历史和趋势&quot;&gt;&lt;a href=&quot;#第一讲：前端开发的历史和趋势&quot; class=&quot;headerlink&quot; title=&quot;第一讲：前端开发的历史和趋势&quot;&gt;&lt;/a&gt;第一讲：&lt;a href=&quot;http://github.kainy.cn/jstraining/history.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端开发的历史和趋势&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;前端开发的历史演变&lt;/li&gt;&lt;li&gt;前端 MVC 框架的兴起&lt;/li&gt;&lt;li&gt;前后端分离&lt;/li&gt;&lt;li&gt;全栈工程师&lt;/li&gt;&lt;li&gt;前端开发的未来&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="培训" scheme="https://blogs.kainy.cn/tags/%E5%9F%B9%E8%AE%AD/"/>
    
      <category term="框架" scheme="https://blogs.kainy.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="测试" scheme="https://blogs.kainy.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="React" scheme="https://blogs.kainy.cn/tags/React/"/>
    
      <category term="Node" scheme="https://blogs.kainy.cn/tags/Node/"/>
    
      <category term="持续集成" scheme="https://blogs.kainy.cn/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>js合并优化实践</title>
    <link href="https://blogs.kainy.cn/2016/11/js%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>https://blogs.kainy.cn/2016/11/js合并优化实践/</id>
    <published>2016-11-17T22:20:16.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>http1.1时代，js资源合并（bundling optimization）仍是一个必要的实践。</p><p>我们在发版前会将入口模块引用的模块打包为一个js，但是对于重用度高的类库如jQ等，如果都合并进来就不太合适了，因为这部分模块改动频率不高，独立加载可发挥浏览器缓存的优势（图1），</p><a id="more"></a><p><img src="http://kainy-migs.stor.sinaapp.com/original/50d5c147c8f04a0f22e195dc3993e634.jpg" alt=""></p><p>所以对打包的工具r.js做了个小改动（图2），打合并包时判断模块尺寸，如果超过20k（经验值），就突出显示，供优化参考；</p><p><img src="http://kainy-migs.stor.sinaapp.com/original/41101a1e5d35600a3b22a637d4e8252d.jpg" alt=""></p><p>执行打包命令的效果（图3），可以看出，在某个入参加密需求中引入的rsa模块由于几乎全局引用到，文件尺寸50k被打入所有包中，这个就应该抽离出来单独加载</p><p><img src="http://kainy-migs.stor.sinaapp.com/original/b6d1ebab9c71ef2cace3be197c8c7132.jpg" alt=""></p><p>前后打包尺寸对比：（图4，图5）通过对比可以看出效果还是比较明显的。</p><p><a href="http://kainy-migs.stor.sinaapp.com/original/d3723bbf081210bc8043298e09ea7bec.jpg" target="_blank" rel="noopener"><img src="http://kainy-migs.stor.sinaapp.com/original/d3723bbf081210bc8043298e09ea7bec.jpg" alt=""></a></p><p>————————————</p><p><a href="http://kainy-migs.stor.sinaapp.com/original/97d02201a96a4b2892bfb232760697b0.jpg" target="_blank" rel="noopener"><img src="http://kainy-migs.stor.sinaapp.com/original/97d02201a96a4b2892bfb232760697b0.jpg" alt=""></a></p><p>分享这个小技巧其实并没啥高深的东东，但从数据来看，产出是正向的，这就所谓“因上努力”。下一篇介绍个监控数据收集的思路，结果上咱们也主动一把。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;http1.1时代，js资源合并（bundling optimization）仍是一个必要的实践。&lt;/p&gt;&lt;p&gt;我们在发版前会将入口模块引用的模块打包为一个js，但是对于重用度高的类库如jQ等，如果都合并进来就不太合适了，因为这部分模块改动频率不高，独立加载可发挥浏览器缓存的优势（图1），&lt;/p&gt;
    
    </summary>
    
      <category term="心路历程" scheme="https://blogs.kainy.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
    
      <category term="性能" scheme="https://blogs.kainy.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="优化" scheme="https://blogs.kainy.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android WebView 前端开发调试</title>
    <link href="https://blogs.kainy.cn/2016/03/Android_WebView_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/"/>
    <id>https://blogs.kainy.cn/2016/03/Android_WebView_前端开发调试/</id>
    <published>2016-03-24T09:44:07.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这次的参数RSA+AES加密需求(160310版本)中，由于涉及的接口众多，测试回归时需要在微信中到相关页面进行验证，工作量巨大，所以需要一个更高效率的<a href="https://slides.com/guotao/mobile-debugging" target="_blank" rel="noopener">移动端调测方式</a>。</p><p><a href="http://iffe.top/blog/%e5%b9%b3%e5%ae%89%e5%86%85%e7%bd%91%e6%a0%87%e8%a3%85%e6%9c%ba%e8%bf%9c%e7%a8%8b%e8%b0%83%e8%af%95%e5%ae%89%e5%8d%93webview%e7%9a%84%e6%96%b9%e6%b3%95/" target="_blank" rel="noopener">这篇文章</a>要里介绍了连接和抓包，其中出现远程调试安卓Webview的截图，很多同事尝试时在列表中只能看到chrome中打开的页面，通过 <a href="http://imweb.io/topic/551b9f7057c4fc5a3a6da6bd" target="_blank" rel="noopener">这篇文章</a>可以知道，原因是其他app可能没有开启webContentsDebuggingEnabled，chrome的安全策略限制了这些网址的展示，要突破这一限制，需要用到一款叫Xposed的APP 。</p><p>Xposed的原理是利用动态劫持，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。</p><a id="more"></a><p>Xposed的安装在<a href="http://sspai.com/24538" target="_blank" rel="noopener">这篇文章</a>中已经介绍了很清楚，这里不赘述。下面截几个过程中的图</p><p><img src="http://kainy-migs.stor.sinaapp.com/original/2cd2eaef26bfbf8c5ac26cb8745b4d86.jpg" alt=""></p><p><img src="http://kainy-migs.stor.sinaapp.com/original/7e2e0bd85521038be8245e0dce8f01b8.jpg" alt=""></p><p><img src="http://kainy-migs.stor.sinaapp.com/original/b80060f2e73e59a3d2781e49676151d8.jpg" alt=""></p><p><img src="http://kainy-migs.stor.sinaapp.com/original/01e235a2bff16c3bf2dbf047634bda5b.png" alt=""></p><p>IMWeb团队袁飞翔这篇文章中介绍了开启QQ客户端debug模式的方法，参考其中代码：</p><p><img src="http://kainy-migs.stor.sinaapp.com/original/7fb84049ed58860fb96b897ca42b8a30.jpg" alt=""></p><p>把里面的 packageName 的判断去掉，重新编<a href="http://pan.baidu.com/s/1gecd5dD" title="提取密码：6abk" target="_blank" rel="noopener">译成apk</a> 就可以啦。也许有童鞋会说“我是前端开发怎么知道如何编译安卓app呢？”</p><p>身为前端，如果说web开发对于我们是陆地，客户端和服务端开发可能就是海洋和天空。离开了陆地我们无法生存，但这不应该成为我们放弃追求上天和入水的理由。</p><p>跳出舒适圈，才能走向更广阔的海洋和天空；正所谓技多不压身，了解其他领域的开发技能，有助于让我们从不同维度来思考工作中遇到的问题，虽然过程中可能需要投入额外的时间，但有的时候放适当放慢解决问题的速度，反而是对个人能力的提升——如果一开始看到那堆java代码感觉和平时写的js语法差异很大，看不懂就放弃了，可能就不会开始APP开发的第一步，更不会去思考如何编译打包的问题。而是直接采用QQ浏览器微信调试工具，这样既省时又省事的方式，但后续如果需调试微信之外的APP就卡壳了，一味追寻捷径也可能让人迷失，尤其对于开发新人。</p><p><em>需要指出的时，Xposed需要root权限（这个对开发应该不是啥问题吧），另外新版本的QQ和微信安卓客户端已经使用X5内核而不调系统Webview了，新版可以尝试在存储卡根目录下放置文件：debug.conf，或者使用老版本的客户端。</em></p><p>参考文章：</p><ol><li><a href="http://imweb.io/topic/551b9f7057c4fc5a3a6da6bd" target="_blank" rel="noopener">使用Xposed强制androidwebView开启debug模式</a></li><li><a href="http://sspai.com/24538" target="_blank" rel="noopener">安卓教程：Xposed 框架安装及使用</a></li><li><a href="http://3dobe.com/archives/113" target="_blank" rel="noopener">Xposed 入门与模块示例 - 电量伪装</a></li><li><a href="http://blog.qqbrowser.cc/kai-qi-wang-ye-diao-shi-jiao-cheng" target="_blank" rel="noopener">QQ浏览器开启网页调试教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这次的参数RSA+AES加密需求(160310版本)中，由于涉及的接口众多，测试回归时需要在微信中到相关页面进行验证，工作量巨大，所以需要一个更高效率的&lt;a href=&quot;https://slides.com/guotao/mobile-debugging&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动端调测方式&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://iffe.top/blog/%e5%b9%b3%e5%ae%89%e5%86%85%e7%bd%91%e6%a0%87%e8%a3%85%e6%9c%ba%e8%bf%9c%e7%a8%8b%e8%b0%83%e8%af%95%e5%ae%89%e5%8d%93webview%e7%9a%84%e6%96%b9%e6%b3%95/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;要里介绍了连接和抓包，其中出现远程调试安卓Webview的截图，很多同事尝试时在列表中只能看到chrome中打开的页面，通过 &lt;a href=&quot;http://imweb.io/topic/551b9f7057c4fc5a3a6da6bd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;可以知道，原因是其他app可能没有开启webContentsDebuggingEnabled，chrome的安全策略限制了这些网址的展示，要突破这一限制，需要用到一款叫Xposed的APP 。&lt;/p&gt;&lt;p&gt;Xposed的原理是利用动态劫持，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://blogs.kainy.cn/categories/JavaScript/"/>
    
    
      <category term="调试" scheme="https://blogs.kainy.cn/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="安卓" scheme="https://blogs.kainy.cn/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>平安内网标装机远程调试安卓webview的方法</title>
    <link href="https://blogs.kainy.cn/2016/01/%E5%B9%B3%E5%AE%89%E5%86%85%E7%BD%91%E6%A0%87%E8%A3%85%E6%9C%BA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93webview%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://blogs.kainy.cn/2016/01/平安内网标装机远程调试安卓webview的方法/</id>
    <published>2016-01-02T22:06:46.000Z</published>
    <updated>2018-12-14T09:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于安全策略限制，我们的开发机只能连入内网，且需要经过标装。</p><p>平安内部主要用到两张网，一张是办公开发用的PA_WLAN，另一张是移动设备接入的MA网，开发机与测试机由于不在同一网段，也就只能上演人鬼情未了了（用Mac开发的土豪例外）；</p><p>另一方面，标装过的机器木有管理员权限，无法通过共享wifi给手机来创建局域网环境，于是另一条路被宣告堵死。</p><p>以往的方法都不灵，只能另辟蹊径咯~ 最终希望寄托在连通二者的USB线。</p><a id="more"></a><p>于是问题转化为：<strong>如何通过USB线实现开发机与测试手机通信，让手机的流量通过USB线走开发机网络</strong>。</p><h3 id="先介绍解题思路"><a href="#先介绍解题思路" class="headerlink" title="先介绍解题思路"></a>先介绍解题思路</h3><ol><li>通过Chrome的远程调试工具连通手机和开发机，实现通信；</li><li>将手机流量通过代理指向开发机端口；</li><li>开发机监听端口，接收代理流量</li></ol><h3 id="具体操作步骤"><a href="#具体操作步骤" class="headerlink" title="具体操作步骤"></a>具体操作步骤</h3><p><strong>针对第一点</strong>，标装机需要安装ADB驱动（没有管理员权限的话到idesk搜索“Android”安装第一个搜索结果）</p><p>[caption id=”” align=”alignnone” width=”507”]<a href="http://kainy-migs.stor.sinaapp.com/original/7a2d487c57fa72a290ce41a1d65d42af.png" target="_blank" rel="noopener"><img src="http://kainy-migs.stor.sinaapp.com/original/7a2d487c57fa72a290ce41a1d65d42af.png" alt=""></a>安装之后，勾选“Extras”下的“Google USB Driver package”，然后安装。[/caption]</p><p>安装之后的操作；</p><ol><li>开启当前Android设备的USB调试模式</li><li>开发机上安装Chrome浏览器（版本&gt;=32）</li><li>用USB线连接Android设备，在PC或MAC上的Chrome地址栏输入chrome://inspect 然后回车，或通过菜单图标→工具→检查设备，进入调试界面</li><li>勾选界面中的 Discover USB devices ，直到搜索到你的Android设备</li><li>在移动设备上弹出的是否允许远程调试上，选择“允许”</li><li>在下面的页面列表（将展示已在Android上的Chrome中打开的页面），点击对应的 inspect 开始调试</li><li>此时将在桌面版Chrome上弹出一个新的标签页，即为调试界面；<br>[caption id=”” align=”alignnone” width=”507”]<img src="http://kainy-migs.stor.sinaapp.com/original/0d090881e4633f59e460b353553aa8ca.jpg" alt=""> 连通后的效果是这样的~[/caption]</li></ol><p>这样以后，开发机的Chrome开发者工具就可以远程调试手机上的Chrome页面，但仅限于Chrome。接下来解决手机APP联网和流量抓包的问题。</p><p><strong>第二点的实现</strong>，得借助一款叫做“Transparent Proxy”的软件实现（需root权限），配置全局代理后，所有APP的流量就都指向Chrome的8888端口了；</p><p>需要注意的是：开发机与手机之间网络连接需要靠大小Chrome通奸来维持，所以即使不是调试手机版Chrome网页，也要保持手机Chrome后台运行状态（即 保持上图中的小绿点常亮）</p><p>[caption id=”” align=”alignnone” width=”267”]<a href="http://kainy-migs.stor.sinaapp.com/original/0d4e25d348f6c1ee7c929b2c9423bc18.jpg" target="_blank" rel="noopener"><img src="http://kainy-migs.stor.sinaapp.com/original/0d4e25d348f6c1ee7c929b2c9423bc18.jpg" alt=""></a>需要如图配置三个地方[/caption]</p><p><strong>第三点</strong>，到目前为止，手机上的流量已经全部转向台式机的Chrome，接下来要做的，是将台式机Chrome接收到的流量转到我们熟悉的抓包工具——Fiddler上</p><p>[caption id=”” align=”alignnone” width=”274”]<img src="http://kainy-migs.stor.sinaapp.com/original/564feabd2260bb3208ef99206ae489f8.jpg" alt=""> Chrome的配置[/caption]</p><p>Fiddler的配置方法就不介绍了，不懂的百度一下，记得勾选“Allow remote computers to connect”哦。</p><p>[caption id=”” align=”alignnone” width=”508”]<a href="http://kainy-migs.stor.sinaapp.com/original/0c1d947659ef874b5dc848f600241926.jpg" target="_blank" rel="noopener"><img src="http://kainy-migs.stor.sinaapp.com/original/0c1d947659ef874b5dc848f600241926.jpg" alt=""></a>财富宝APP的抓包，从User-Agent值可以看到系统和内核信息[/caption]</p><p>目前我们用较多的是console.re 和blog.qqbrowser.cc的方案；</p><ul><li>方案一本质是模拟console，依赖第三方服务器且存在网络延迟问题，功能也远不及Chrome开发者工具强大；</li><li>方案二需要安装鹅厂产品，不过相比带来的调试便利，这点推广还算良心。另外这个方案只能调试内核使用x5的APP，如微信、QQ空间等，且对APP版本有要求，如微信6.1以后才支持x5内核。<br>相比之下，咱们这套方法有三个优势：</li></ul><ol><li>不需要专门去安装个QQ浏览器用于调试（对于办公机内存吃紧如我的同学而言还是蛮赞的）；</li><li>不仅限于X5内核，可调试所有安卓应用中的webview；</li><li>手机使用开发机网络，无需MA账号，妈妈再也不用担心你的手机流量~</li></ol><h3 id="最终实现的效果"><a href="#最终实现的效果" class="headerlink" title="最终实现的效果"></a>最终实现的效果</h3><p>[caption id=”” align=”alignnone” width=”508”]<a href="http://kainy-migs.stor.sinaapp.com/original/2201bd030fe674a53f69ccb0862c8b64.jpg" target="_blank" rel="noopener"><img src="http://kainy-migs.stor.sinaapp.com/original/2201bd030fe674a53f69ccb0862c8b64.jpg" alt=""></a>手机上打开页面的列表，点击“inspect”开始调试[/caption]</p><p>[caption id=”” align=”alignnone” width=”507”]<a href="http://kainy-migs.stor.sinaapp.com/original/9877ff22b5f74ef5a6450767fcdcf3bc.jpg" target="_blank" rel="noopener"><img src="http://kainy-migs.stor.sinaapp.com/original/9877ff22b5f74ef5a6450767fcdcf3bc.jpg" alt=""></a>远程调试Chrome中打开的页面[/caption]</p><p>[caption id=”” align=”alignnone” width=”507”]<a href="http://kainy-migs.stor.sinaapp.com/original/5b3e164808cf6fd89973f38fd9bb101c.jpg" target="_blank" rel="noopener"><img src="http://kainy-migs.stor.sinaapp.com/original/5b3e164808cf6fd89973f38fd9bb101c.jpg" alt=""></a>远程调试APP webview中的页面[/caption]</p><p>[caption id=”” align=”alignnone” width=”506”]<a href="http://kainy-migs.stor.sinaapp.com/original/cb87eec44182dd0370992051828be327.jpg" target="_blank" rel="noopener"><img src="http://kainy-migs.stor.sinaapp.com/original/cb87eec44182dd0370992051828be327.jpg" alt=""></a>远程调试微信webview中的页面[/caption]</p><p>不将就于console.re模拟调试、不局限于仅满足特定场景的调试方案，要就用最直接的开发工具，做有追求的开发者（追求高效、追求简单、追求纯粹、追求XX… ）。</p><p>迂回妥协的方案如：设置全局开关 然后判断页面运行环境切换开关 虽然也是经验的结晶，但终究影响开发效率和体验。</p><p>面对外部条件和环境给开发带来的不便，我们还是要保持有开发者的初心，而不是以此为理由降低对开发过程和自己的要求，相信有光，于是光就在前方不远处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于安全策略限制，我们的开发机只能连入内网，且需要经过标装。&lt;/p&gt;&lt;p&gt;平安内部主要用到两张网，一张是办公开发用的PA_WLAN，另一张是移动设备接入的MA网，开发机与测试机由于不在同一网段，也就只能上演人鬼情未了了（用Mac开发的土豪例外）；&lt;/p&gt;&lt;p&gt;另一方面，标装过的机器木有管理员权限，无法通过共享wifi给手机来创建局域网环境，于是另一条路被宣告堵死。&lt;/p&gt;&lt;p&gt;以往的方法都不灵，只能另辟蹊径咯~ 最终希望寄托在连通二者的USB线。&lt;/p&gt;
    
    </summary>
    
      <category term="建站❤编程" scheme="https://blogs.kainy.cn/categories/%E5%BB%BA%E7%AB%99%E2%9D%A4%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="调试" scheme="https://blogs.kainy.cn/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="android" scheme="https://blogs.kainy.cn/tags/android/"/>
    
      <category term="webview" scheme="https://blogs.kainy.cn/tags/webview/"/>
    
  </entry>
  
</feed>
