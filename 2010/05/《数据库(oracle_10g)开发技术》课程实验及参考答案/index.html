<!doctype html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="oracle,数据库,实验,答案,"><link rel="alternate" href="/atom.xml" title="Freetao's Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="https://kainy.cn/favicon.ico?v=5.1.0"><meta name="description" content="课程使用教材：《Oracle 10g SQL和PL/SQL编程指南》一、 实验目的《数据库开发技术》课程之实验三连接查询，集合运算，子查询和 TOP-N 分析1． 掌握分组查询，连接查询和集合运算的使用方法。2． 掌握子查询的使用，包括在：having 子句中；from 子句中；CREATE, UPDATA, INSERT, DELETE 语句中；3． 掌握多列子查询和相关子查询的使用。。4． 掌"><meta name="keywords" content="oracle,数据库,实验,答案"><meta property="og:type" content="article"><meta property="og:title" content="《数据库(oracle 10g)开发技术》课程实验及参考答案"><meta property="og:url" content="https://blogs.kainy.cn/2010/05/《数据库(oracle_10g)开发技术》课程实验及参考答案/index.html"><meta property="og:site_name" content="Freetao&#39;s Blog"><meta property="og:description" content="课程使用教材：《Oracle 10g SQL和PL/SQL编程指南》一、 实验目的《数据库开发技术》课程之实验三连接查询，集合运算，子查询和 TOP-N 分析1． 掌握分组查询，连接查询和集合运算的使用方法。2． 掌握子查询的使用，包括在：having 子句中；from 子句中；CREATE, UPDATA, INSERT, DELETE 语句中；3． 掌握多列子查询和相关子查询的使用。。4． 掌"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-12-14T09:35:52.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《数据库(oracle 10g)开发技术》课程实验及参考答案"><meta name="twitter:description" content="课程使用教材：《Oracle 10g SQL和PL/SQL编程指南》一、 实验目的《数据库开发技术》课程之实验三连接查询，集合运算，子查询和 TOP-N 分析1． 掌握分组查询，连接查询和集合运算的使用方法。2． 掌握子查询的使用，包括在：having 子句中；from 子句中；CREATE, UPDATA, INSERT, DELETE 语句中；3． 掌握多列子查询和相关子查询的使用。。4． 掌"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://blogs.kainy.cn/2010/05/《数据库(oracle_10g)开发技术》课程实验及参考答案/"><title>《数据库(oracle 10g)开发技术》课程实验及参考答案 | Freetao's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Freetao's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">关♥生活，关注互联网。</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div><span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://blogs.kainy.cn/2010/05/《数据库(oracle_10g)开发技术》课程实验及参考答案/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Kainy Guo"><meta itemprop="description" content=""><meta itemprop="image" content="//tva2.sinaimg.cn/crop.0.0.180.180.180/4d6e3e3bjw1e8qgp5bmzyj2050050aa8.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Freetao's Blog"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Freetao's Blog" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《数据库(oracle 10g)开发技术》课程实验及参考答案</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2010-05-08T12:33:24+00:00">2010-05-08 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/课件❤资料/" itemprop="url" rel="index"><span itemprop="name">课件❤资料</span> </a></span></span><span id="/2010/05/《数据库(oracle_10g)开发技术》课程实验及参考答案/" class="leancloud_visitors" data-flag-title="《数据库(oracle 10g)开发技术》课程实验及参考答案"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>课程使用教材：《Oracle 10g SQL和PL/SQL编程指南》</p><p><strong>一、</strong> <strong>实验目的</strong></p><p><strong>《数据库开发技术》课程之实验三</strong></p><p><strong>连接查询，集合运算，子查询和</strong> <strong>TOP-N</strong> <strong>分析</strong></p><p>1． 掌握分组查询，连接查询和集合运算的使用方法。</p><p>2． 掌握子查询的使用，包括在：</p><p>having 子句中；</p><p>from 子句中；</p><p>CREATE, UPDATA, INSERT, DELETE 语句中；</p><p>3． 掌握多列子查询和相关子查询的使用。。</p><p>4． 掌握 TOP-N 分析方法；</p><p><strong>二、</strong> <strong>实验内容和要求</strong></p><p><strong>第一部分：使用</strong> <strong>SQL</strong> <strong>语句完成以下查询要求。</strong></p><ol><li>查询使用红色零件的工程名称。(考核多表（三表）连接操作) (分别使用相关的子查询、带 in 谓词的子</li></ol><p>查询、带 exists 谓词的子查询和连接查询实现。注意体会不同实现方式的区别。实验报告要求写出其中</p><p>的两种方法)</p><p>/<em> 连接查询 </em>/</p><p>select distinct jname from j,spj,p where p.pno=spj.pno and spj.jno=j.jno and color=’红’</p><p>jname</p><hr><p>弹簧厂</p><p>三建</p><p>一汽</p><p>造船厂</p><p>/<em>三层带 IN 谓词的嵌套查询 </em>/</p><p>select jname from j where jno in –这里上题有的 distinct 可以不需要</p><p>(select jno from spj where pno in</p><p>(select pno from p where color=’红’));</p><p>/<em> 带 exists 的子查询 </em>/</p><p>Select jname from j where exists</p><p>(Select * from spj where jno=j.jno and exists</p><p>(select * from p</p><p>where pno=spj.pno and color=’红’));</p><p>/<em> 相关的子查询 </em>/</p><p>Select jname from j where jno in</p><p>(Select jno from spj where jno=j.jno and ‘红’=</p><p>(select color from p</p><p>where pno=spj.pno));</p><p>.OR.</p><p>Select jname from j where jno in</p><p>(Select jno from spj where jno=j.jno and pno in</p><p>(select pno from p</p><p>where pno=spj.pno and color=’红’));</p><p>.OR.</p><p>Select jname from j where ‘红’ in</p><p>(Select color from p,spj</p><p>Where p.pno=spj.pno and jno=j.jno);</p><ol start="2"><li>*查询每一种零件被供应的次数，要求：</li></ol><p>1）结果显示零件号、零件名称和被供应的次数。</p><p>2）零件表中的所有零件都要统计。</p><p>SELECT P.PNO, PNAME, COUNT(SPJ.PNO)</p><p>FROM P left outer join SPJ –必须使用外连接</p><p>ON P.PNO = SPJ.PNO</p><p>GROUP BY P.PNO, PNAME</p><p>.OR.</p><p>SELECT P.PNO, PNAME, COUNT(SPJ.PNO) COUNT_P</p><p>FROM P, SPJ</p><p>WHERE P.PNO = SPJ.PNO(+)</p><p>GROUP BY P.PNO, PNAME;</p><p>显示效果形如下：</p><p>PNO PNAME COUNT_P</p><hr><p>P1 螺母 4</p><p>P2 螺栓 2</p><p>P3 螺丝刀 5</p><p>P4 螺丝刀 0</p><p>P5 凸轮 3</p><p>P6 齿轮 3</p><p>P7 把手 0</p><p>已选择 7 行。</p><p>问题 1？GROUP BY P.PNO 还是 SPJ.PNO?</p><p>Answer: P.PNO</p><p>问题 2？GROUP BY P.PNO 和 GROUP BY P.PNO, PNAME 结果是否一样？</p><p>Answer: 一样, 如果只要求显示零件号。如果要求显示的是零件号和零件名称，则必须要用 GROUP BY</p><p>P.PNO, PNAME。</p><p>问题 3？COUNT(SPJ.PNO)还是 COUNT(P.PNO)</p><p>Answer: COUNT(SPJ.PNO)，否则将那些没有供应过的零件也计算了一次，因为 P 中所有的零件都有机会出</p><p>现在查询结果中，不管有没有被供应过。</p><p>问题 4？如果查询结果不要求显示零件号，只要求显示零件名称和数量，以下这个 SQL 语句对吗？</p><p>SELECT PNAME, COUNT(SPJ.PNO)</p><p>FROM P, SPJ</p><p>WHERE P.PNO = SPJ.PNO(+)</p><p>GROUP BY PNAME;</p><p>Answer: 不对，P 表的 PNAME 有可能重复</p><p>正确的还是要用：</p><p>SELECT PNAME, COUNT(SPJ.PNO)</p><p>FROM P, SPJ</p><p>WHERE P.PNO = SPJ.PNO(+)</p><p>GROUP BY P.PNO, PNAME;</p><ol start="3"><li>查询 student 表中各系学生数占全校学生人数的百分比</li></ol><p>SELECT A.sdept, ROUND((A.s_sum / B.s_total)*100,1) “%Student”</p><p>FROM (SELECT sdept, COUNT(sno) s_sum</p><p>FROM student</p><p>GROUP BY sdept) A,</p><p>(SELECT COUNT(sno) s_total</p><p>FROM student) B;</p><p><strong>.OR.</strong></p><p>SELECT sdept, ROUND(count(sno) / (select count(sno) from student)*100,1) “%Student”</p><p>FROM student</p><p>GROUP BY sdept;</p><p>SDEPT %Student</p><hr><p>CS 33.3</p><p>FL 22.2</p><p>IS 22.2</p><p>MA 22.2</p><p>已选择 4 行。</p><ol start="4"><li>查询工资高于本部门平均工资的员工信息。</li></ol><p>select *</p><p>from emp outer</p><p>where sal&gt;(select avg(sal)</p><p>from emp</p><p>where outer.deptno=emp.deptno</p><p>group by deptno)</p><p>.OR.</p><p>select *</p><p>from emp outer</p><p>where sal&gt;(select avg(sal)</p><p>from emp</p><p>where outer.deptno=emp.deptno)</p><ol start="5"><li>显示与 30 部门任何雇员薪水及岗位相匹配的雇员的姓名、部门编号、薪水及佣金。</li></ol><p>SELECT ename, deptno, sal, comm</p><p>FROM emp</p><p>WHERE sal IN (SELECT sal</p><p>FROM emp</p><p>WHERE deptno = 30)</p><p>AND job IN (SELECT job</p><p>FROM emp</p><p>WHERE deptno = 30);</p><ol start="6"><li>*显示部门的雇员比部门 20 的雇员更多的部门的名称。</li></ol><p>Select dname</p><p>From emp,dept</p><p>Where emp.deptno=dept.deptno</p><p>Group by emp.deptno,dname</p><p>Having count(empno)&gt;(select count(empno)</p><p>From emp</p><p>Where deptno=20);</p><p>DNAME</p><hr><p>SALES</p><p>.OR.</p><p>已选择 1 行。</p><p>Select dname</p><p>From dept</p><p>Where deptno in</p><p>(select deptno from emp</p><p>Group by deptno</p><p>Having count(empno)&gt;(select count(empno)</p><p>From emp</p><p>Where deptno=20));</p><ol start="7"><li>查询其他系中比计算机科学系某一学生年龄大的学生姓名与年龄，用两种方法实现，写其中一种即可。</li></ol><p><strong>SELECT Sname, Sage FROM Student</strong></p><p><strong>WHERE Sage &gt;</strong> <strong>ANY ( SELECT Sage</strong></p><p><strong>FROM Student</strong></p><p><strong>WHERE Sdept=’CS’)</strong> <strong>AND Sdept&lt;&gt;’CS’;</strong></p><p>/<em> <strong>方法二：</strong> </em>/</p><p><strong>SELECT Sname, Sage FROM Student</strong></p><p><strong>WHERE Sage &gt;</strong> <strong>( SELECT min(Sage)</strong></p><p><strong>FROM Student</strong></p><p><strong>WHERE Sdept=’CS’)</strong> <strong>AND Sdept&lt;&gt;’CS’;</strong></p><p>SNAME SAGE</p><hr><p>张军 21</p><ol start="8"><li>*查询至少选修了学生 95002 选修的全部课程的学生学号(不包括 95002 学生本身)。</li></ol><p><strong>SELECT DISTINCT Sno FROM SC SCX</strong></p><p><strong>WHERE sno&lt;&gt;’95002’ and NOT EXISTS –</strong> <strong>不存在</strong></p><p><strong>(SELECT * FROM SC SCY – 95002</strong> <strong>学生选修的课程</strong></p><p><strong>WHERE SCY.Sno=’95002’ AND</strong></p><p><strong>NOT EXISTS – X</strong> <strong>学生没有选修同一课程</strong></p><p><strong>( SELECT * FROM SC SCZ</strong></p><p><strong>WHERE SCZ.Sno=SCX.Sno</strong></p><p><strong>AND SCZ.Cno=SCY.Cno));</strong></p><p>SNO</p><hr><p>95001</p><p><strong>附加题：</strong></p><ol><li>*查询工资第 3 低的员工的工号、姓名和薪水（假设 SAL 子段作了惟一限制。）（提示：使用 from 子查</li></ol><p>询语句、内嵌视图和 ROWNUM 伪列）</p><p>select empno,ename,sal</p><p>from (select empno,ename,sal from</p><p>(select empno,ename,sal from emp</p><p>order by sal)</p><p>where rownum&lt;=3 order by sal desc)</p><p>where rownum&lt;=1;</p><p>EMPNO ENAME SAL</p><hr><p>7876 ADAMS 1100</p><p>已选择 1 行。</p><p>.OR.</p><p>select empno,ename,sal</p><p>from (Select rownum topn,empno,ename,sal</p><p>From (select empno,ename,sal from emp</p><p>Order by sal)</p><p>Where rownum&lt;=3) a</p><p>where topn=3;</p><p>.OR.</p><p>select empno,ename,sal</p><p>from (Select rownum,empno,ename,sal</p><p>from emp</p><p>Order by sal)</p><p>Where rownum&lt;=3</p><p>Minus</p><p>select empno,ename,sal</p><p>from (Select rownum,empno,ename,sal</p><p>from emp</p><p>Order by sal)</p><p>Where rownum&lt;=2;</p><p>.OR.</p><p>select empno,ename,sal from – 此法的前题是工资值是不雷同的，这种解法适合于查找一列中</p><p>– 第 N 大值或第 N 小值</p><p>(select emp.*,dense_rank() over (order by sal) rank from emp)</p><p>where rank = 3;</p><p><strong>第二部分：</strong></p><p>自己设计实例完成在 CREATE, UPDATA, INSERT, DELETE 语句中使用子查询的实验；</p><p><strong>三、</strong> <strong>实验报告</strong></p><p>根据实验内容要求写出相应的 SQL 语句，并记录实验过程中遇到的困难和解决问题的方</p><p>法。(实验报告中不要求写加*题目的实验过程和内容)</p><p>实验参考数据：</p><p>CREATE TABLE STUDENT(</p><p>SNO</p><p>NUMBER(5) PRIMARY KEY ,</p><p>SNAME VARCHAR2(20) ,</p><p>SSEX</p><p>CHAR(2)</p><p>,</p><p>SAGE</p><p>NUMBER(3) ,</p><p>SDEPT VARCHAR2(10) );</p><p>CREATE TABLE COURSE(</p><p>CNO</p><p>NUMBER(4) PRIMARY KEY,</p><p>CNAME VARCHAR2(30),</p><p>CPNO NUMBER(4),</p><p>CCREDIT NUMBER(2),</p><p>CLIMIT NUMBER(4));</p><p>CREATE TABLE SC(</p><p>SNO</p><p>CNO</p><p>NUMBER(5) ,</p><p>NUMBER(4) ,</p><p>GRADE NUMBER(3,1) ,</p><p>PRIMARY KEY(SNO,CNO));</p><p>INSERT INTO STUDENT VALUES(95001,’李明勇’,’男’,20,’CS’);</p><p>INSERT INTO STUDENT VALUES(95002,’刘晨’,’女’,19,’IS’);</p><p>INSERT INTO STUDENT VALUES(95003,’王名’,’女’,18,’MA’);</p><p>INSERT INTO STUDENT VALUES(95004,’张立’,’男’,19,’CS’);</p><p>INSERT INTO STUDENT VALUES(95005,’张军’,’男’,21,’MA’);</p><p>INSERT INTO STUDENT VALUES(95006,’王张凤’,’女’,19,’FL’);</p><p>INSERT INTO STUDENT VALUES(95007,’王敬’,’女’,18,’IS’);</p><p>INSERT INTO STUDENT VALUES(95008,’张名惠’,’男’,19,’FL’);</p><p>COMMIT;</p><p>INSERT INTO COURSE VALUES(1,’数据库’,5,5,10);</p><p>INSERT INTO COURSE VALUES(2,’数学’,NULL,3,10);</p><p>INSERT INTO COURSE VALUES(3,’信息系统’,1,4,12);</p><p>INSERT INTO COURSE VALUES(4,’操作系统’,6,4,12);</p><p>INSERT INTO COURSE VALUES(5,’数据结构’,7,5,16);</p><p>INSERT INTO COURSE VALUES(6,’数据处理’,NULL,3,15);</p><p>INSERT INTO COURSE VALUES(7,’PASCAL 语言’,6,2,NULL);</p><p>COMMIT;</p><p>INSERT INTO SC VALUES(95001,5,92);</p><p>INSERT INTO SC VALUES(95002,3,80);</p><p>INSERT INTO SC VALUES(95001,1,58);</p><p>INSERT INTO SC VALUES(95002,2,90);</p><p>INSERT INTO SC VALUES(95003,3,NULL);</p><p>INSERT INTO SC VALUES(95001,3,70);</p><p>INSERT INTO SC VALUES(95002,1,84.5);</p><p>INSERT INTO SC VALUES(95003,2,67);</p><p>INSERT INTO SC VALUES(95007,2,NULL);</p><p>INSERT INTO SC VALUES(95008,1,34.5);</p><p>INSERT INTO SC VALUES(95001,2,85);</p><p>COMMIT;</p><p>create table stuscore(cname varchar2(30),grade NUMBER(3,1), sno number(5));</p><p>insert into stuscore values(‘数据库’,78,95001);</p><p>insert into stuscore values(‘信息系统’,80,95001);</p><p>insert into stuscore values(‘操作系统’,90,95001);</p><p>insert into stuscore values(‘数据库’,79,95002);</p><p>insert into stuscore values(‘信息系统’,82,95002);</p><p>insert into stuscore values(‘操作系统’,92,95002);</p><p>COMMIT;</p><p>INSERT INTO SC VALUES(95007,2,45);</p><p>INSERT INTO SC VALUES(95007,1,44);</p><p>INSERT INTO SC VALUES(95007,3,64);</p><p>INSERT INTO SC VALUES(95007,4,34);</p><p>INSERT INTO SC VALUES(95007,5,50);</p><p>INSERT INTO SC VALUES(95007,6,20);<br></p><p><strong>一、</strong> <strong>实践目的</strong></p><p><strong>《数据库开发技术》课程之实验四</strong></p><p><strong>控制结构和嵌入式</strong> <strong>SQL</strong></p><p>1． 掌握 PL/SQL 程序设计的基本知识。</p><p>2． 掌握 PL/SQL 中控制结构的使用。具体包括：</p><p>选择结构（IF 语句和 CASE 语句）；</p><p>循环结构（三种循环语句）：</p><p>3． 掌握 PL/SQL 中 SELECT 语句和 DML 语句的正确使用方法。</p><p><strong>二、</strong> <strong>实践内容和要求</strong></p><ol><li>通过 CASE 语句判断 7788 雇员的工资等级后输出，工资等级划分条件是：3000(含)以上为高，1500（含）</li></ol><p>至 3000 为中，低于 1500 为低。</p><p>SET SERVEROUTPUT ON</p><p>DECLARE</p><p>v_sal NUMBER(5);</p><p>BEGIN</p><p>SELECT sal INTO v_sal FROM emp WHERE empno=7788;</p><p>CASE</p><p>WHEN v_sal&gt;=3000 THEN DBMS_OUTPUT.PUT_LINE(‘工资等级：高’);</p><p>WHEN v_sal&gt;=1500 THEN DBMS_OUTPUT.PUT_LINE(‘工资等级：中’);</p><p>ELSE DBMS_OUTPUT.PUT_LINE(‘工资等级：低’);</p><p>END CASE;</p><p>END;</p><p>执行结果为：</p><p>工资等级：高</p><p>PL/SQL 过程已成功完成。</p><ol start="2"><li>用 PL/SQL 的 FOR 循环输出以下实心三角形:</li></ol><p>1 *</p><p>2 ***</p><p>3 <strong>*</strong></p><p>4 <strong>***</strong></p><p>5 <strong><strong>*</strong></strong></p><p>Set serveroutput on</p><p>BEGIN</p><p>FOR I IN 1..5 LOOP –采用 FOR 循环结构</p><p>DBMS_OUTPUT.PUT_LINE(to_char(I)||rpad(‘ ‘,8-I,’ ‘)||rpad(‘<em>‘,2</em>I-1,’*’));</p><p>END LOOP;</p><p>END;</p><p>或者</p><p>DECLARE</p><p>String varchar2(20);</p><p>BEGIN</p><p>FOR I IN 1..5 LOOP –采用 FOR 循环结构</p><p>String:=(i|| rpad(‘ ‘,5)||substr(‘</p><p>‘,1,(5-i))||substr(‘<strong><strong>*</strong></strong>’,1,(i*2-1)));</p><p>END;</p><p>DBMS_OUTPUT.PUT_LINE(string);</p><p>END LOOP;</p><ol start="3"><li>先创建 d_asc 表。再编写一个匿名 PL/SQL 块，实现往此表插入 ASCII 码值从 32 至 126 的码号和相应</li></ol><p>码值的字符。(提示：用 CHR()函数, 要求分别用两种循环方法实现)。</p><p>create table d_asc(n number, a char);</p><p>begin</p><p>for i in 32..126 loop –FOR loop 有计数的循环</p><p>insert into d_asc values(i, chr(i)); –PL/SQL 中嵌入了 DML 语句</p><p>end loop;</p><p>commit;</p><p>end;</p><p>/</p><p>/<em> 检查 PL/SQL 程序块执行结果</em>/</p><p>Select * from d_asc;</p><p><strong>.OR.</strong></p><p>declare</p><p>i number(4):=32;</p><p>begin</p><p>while i&lt;=126 loop –WHILE loop 有条件的循环</p><p>insert into d_asc values(i, chr(i));</p><p>i:=i+1;</p><p>end loop;</p><p>commit;</p><p>end;</p><p>/</p><p><strong>附加题：</strong></p><p>用 PL/SQL 的循环语句编程，求：1２+3２+5２+…+13２+15２ 的值。</p><p>SET SERVEROUTPUT ON</p><p>DECLARE</p><p>v_sub NUMBER(5):=12;</p><p>v_sum NUMBER(5):=0;</p><p>BEGIN</p><p>LOOP</p><p>v_sum:=v_sum+v_sub;</p><p>v_sub:=v_sub+20;</p><p>EXIT WHEN v_sub&gt;152;</p><p>END LOOP;</p><p>DBMS_OUTPUT.PUT_LINE(v_sum);</p><p>END;</p><p>执行结果为：</p><p>656</p><p>PL/SQL 过程已成功完成。<br></p><p><strong>一、</strong> <strong>实验目的</strong></p><p><strong>《数据库开发技术》课程之实验五</strong></p><p><strong>PL/SQL</strong> <strong>的游标和异常处理</strong></p><ol><li><p>掌握游标和参数化游标的使用方法。</p></li><li><p>掌握游标 FOR 循环、SELECT…FOR UPDATE 游标和 WHERE CURRENT OF 子句的</p></li></ol><p>使用方法。</p><p><strong>3.</strong> <strong>实验内容和要求</strong></p><ol><li>编写匿名 PL/SQL 程序块，根据用户输入的部门编号实现在 PL/SQL 中逐行显示 emp 表中该部门员</li></ol><p>工的工资级别。工资级别是：当工资为空时，为空，工资在 1000 元以下的为‘低’，在 1000 和 3000</p><p>之间的为‘中’，高于 3000 元的为‘高’。要求使用参数化游标。</p><p>declare</p><p>v_deptno emp.deptno%type;</p><p>cursor c_emp(cp_deptno emp.deptno%type)</p><p>is select empno,sal from emp where deptno=cp_deptno;</p><p>v_emp c_emp%rowtype;</p><p>v_lev varchar2(6);</p><p>begin</p><p>v_deptno:= &amp;dept_id</p><p>open c_emp(v_deptno); –还可采用游标 FOR 循环等其他方法</p><p>loop</p><p>fetch c_emp into v_emp;</p><p>exit when c_emp%notfound;</p><p>if v_emp.sal is null then</p><p>v_lev:=null;</p><p>elsif v_emp.sal&lt;1000 then</p><p>v_lev:=’低’;</p><p>elsif v_emp.sal&gt;=1000 and v_emp.sal&lt;3000 then</p><p>v_lev:=’中’;</p><p>elsif v_emp.sal&gt;=3000 then</p><p>v_lev:=’高’;</p><p>end if;</p><p>dbms_output.put_line(v_emp.empno||’,’||v_emp.sal||’,’||v_lev);</p><p>end loop;</p><p>close c_emp;</p><p>end;</p><p>/</p><ol start="2"><li>创建一个 PL/SQL 块，要求根据用户输入的员工编号（EMPNO），查询出 EMP 表中该编号员工所</li></ol><p>在的部门编号(deptno)及其直接管理者的姓名(ename)，要有异常处理(该员工编号不存在)。查询效</p><p>果形如下：</p><p>declare</p><p>v_empno emp.empno%type;</p><p>v_deptno emp.deptno%type;</p><p>v_mgrname emp.ename%type;</p><p>begin</p><p>v_empno:= &amp;员工编号;</p><p>select e.deptno, m.ename into v_deptno, v_mgrname</p><p>from emp e left outer join emp m on e.mgr=m.empno –这里使用自身外连接确保无主管的员工也能正常处理</p><p>where e.empno=v_empno;</p><p>dbms_output.put_line(‘员工编号’||lpad(‘ ‘,5)||’部门编号’||lpad(‘ ‘,5)||’上司姓名’);</p><p>dbms_output.put_line(lpad(‘-‘,34,’-‘));</p><p>dbms_output.put_line(v_empno||lpad(‘ ‘,10)||v_deptno||lpad(‘ ‘,10)| v_mgrname);</p><p>EXCEPTION</p><p>when no_data_found then</p><p>dbms_output.put_line(‘该员工不存在！’);</p><p>end;</p><p>/</p><p>或者</p><p>declare</p><p>v_empno emp.empno%type;</p><p>no_exist_empno exception;</p><p>v_deptno emp.deptno%type;</p><p>v_mgrname emp.ename%type;</p><p>begin</p><p>v_empno:= &amp;员工编号;</p><p>update emp set sal=sal where empno=v_empno;</p><p>if SQL%rowcount=0 then</p><p>raise no_exist_empno; –显式抛出用户自定义的异常</p><p>end if;</p><p>select e.deptno, m.ename into v_deptno, v_mgrname</p><p>from emp e, emp m</p><p>where e.empno=v_empno and e.mgr=m.empno;</p><p>dbms_output.put_line(‘员工编号’||lpad(‘ ‘,5)||’部门编号’||lpad(‘ ‘,5)||’上司姓名’);</p><p>dbms_output.put_line(lpad(‘-‘,34,’-‘));</p><p>dbms_output.put_line(v_empno||lpad(‘ ‘,10)| v_deptno||lpad(‘ ‘,10)||v_mgrname);</p><p>EXCEPTION</p><p>when no_exist_empno then</p><p>dbms_output.put_line(‘该员工不存在！’);</p><p>when no_data_found then</p><p>dbms_output.put_line(‘该员工是总裁，无直接主管！’);</p><p>end;</p><p>/</p><p>或者</p><p>declare</p><p>v_empno emp.empno%type;</p><p>no_exist_empno exception;</p><p>cursor c_emp(cp_empno emp.empno%type)</p><p>is select e.empno, e.deptno, m.ename</p><p>from emp e left outer join emp m on e.mgr=m.empno</p><p>where e.empno=cp_empno;</p><p>v_emp c_emp%rowtype;</p><p>begin</p><p>v_empno:= &amp;emp_id;</p><p>open c_emp(v_empno);</p><p>fetch c_emp into v_emp;</p><p>if c_emp%notfound then</p><p>raise no_exist_empno;</p><p>end if;</p><p>dbms_output.put_line(‘员工编号’||lpad(‘ ‘,5)||’部门编号’||lpad(‘ ‘,5)||’上司姓名’);</p><p>dbms_output.put_line(lpad(‘-‘,34,’-‘));</p><p>dbms_output.put_line(v_emp.empno||lpad(‘ ‘,10)||v_emp.deptno||lpad(‘ ‘,10)| v_emp.ename);</p><p>close c_emp;</p><p>EXCEPTION</p><p>when no_exist_empno then</p><p>dbms_output.put_line(‘该员工不存在！’);</p><p>end;</p><p>/</p><ol start="3"><li>*创建一个 PL/SQL 块，根据输入的部门编号，逐条输出 EMP 表中该部门每位员工的编号(empno)、</li></ol><p>姓名(ename)和工资(sal)信息，要求用游标实现，信息显示格式要求如下：</p><p>编号</p><p>姓名</p><p>工资</p><p>declare</p><p>7396</p><p>PETER 1500.00</p><p>v_deptno emp.deptno%type := &amp;dept_id;</p><p>cursor c_emp(cp_deptno emp.deptno%type)</p><p>is select empno, ename, sal from emp where deptno=cp_deptno;</p><p>v_emp c_emp%rowtype;</p><p>begin</p><p>if not c_emp%isopen then</p><p>open c_emp(v_deptno);</p><p>end if;</p><p>dbms_output.put_line(‘编号’| lpad(‘ ‘,10)||’姓名’||lpad(‘ ‘,10)||’工资’);</p><p>loop</p><p>fetch c_emp into v_emp;</p><p>exit when c_emp%notfound;</p><p>dbms_output.put_line(v_emp.empno||lpad(‘ ‘,10)||rpad(v_emp.ename,10)||lpad(‘ ‘,4)| v_emp.sal);</p><p>end loop;</p><p>close c_emp;</p><p>end;</p><ol start="4"><li>创建一个 PL/SQL 块，每输出 DEPT 表的一条记录（DEPTNO,DNAME,LOC）后，随后输出该部门</li></ol><p>的员工记录（EMPNO,ENAME,HIREDATE,SAL），输出格式形如下：</p><p>部门编号:10 部门名称:SALES</p><p>部门位置:DALAS</p><p>――――――――――――――――――――――――――――</p><p>7369</p><p>KING</p><p>05-12-87 $1500</p><p>7135 PETER 03-22-89 $1100</p><p>……………………</p><p>部门编号:20 部门名称:PROGRAM 部门位置: BOSTON</p><p>――――――――――――――――――――――――――――</p><p>7029</p><p>JOHN</p><p>05-12-87 $1200</p><p>BEGIN</p><p>……………………</p><p>FOR dept_rec in (select * from dept) loop</p><p>dbms_output.put_line(‘部门编号:’|| dept_rec.deptno||lpad(‘ ‘,5)</p><p>||’部门名称:’||rpad(dept_rec.dname,10)||lpad(‘ ‘,5)||’部门位置:’| dept_rec.loc);</p><p>dbms_output.put_line(lpad(‘-‘,58,’-‘));</p><p>FOR emp_rec in (select empno, ename, to_char(hiredate, ‘mm-dd-yy’) HD, to_char(sal, ‘$99999’) salary</p><p>from emp Where deptno= dept_rec.deptno) LOOP</p><p>dbms_output.put_line(emp_rec.empno||lpad(‘ ‘,10)||rpad(emp_rec.ename,10)||lpad(‘ ‘,8)</p><p>|| emp_rec.HD||lpad(‘ ’,8)||emp_rec.salary);</p><p>END loop;</p><p>END loop;</p><p>END;</p><ol start="5"><li>*有这么一张表 t_t，他只有一个 number(8)的字段 a，由于在创建表时忘记设置主键约束，导致表中</li></ol><p>有很多重复的记录。请你编写一个程序，将表中重复的记录保留一个，删除其余的。</p><p>create table t_t(a number(8));</p><p>insert into t_t values(1);</p><p>insert into t_t values(3);</p><p>insert into t_t values(6);</p><p>insert into t_t values(1);</p><p>insert into t_t values(6);</p><p>insert into t_t values(5);</p><p>insert into t_t values(3);</p><p>insert into t_t values(1);</p><p>insert into t_t values(1);</p><p>declare</p><p>cursor c_t is</p><p>select distinct a from t_t ;</p><p>v_t c_t%rowtype;</p><p>begin</p><p>open c_t;</p><p>delete from t_t;</p><p>loop</p><p>fetch c_t into v_t;</p><p>exit when c_t%notfound;</p><p>dbms_output.put_line(to_char(v_t.a));</p><p>insert into t_t values(v_t.a);</p><p>end loop;</p><p>commit;</p><p>close c_t;</p><p>end;</p><p>– 可以通过查看表 t_t 的值来验证程序的执行情况。</p><p>Select * from t_t;</p><ol start="6"><li>*利用 REF 游标（游标变量）完成以下组合查询任务: 根据姓名、所在系任意组合查询学员信息。</li></ol><p>DECLARE</p><p>l_name student.sname%TYPE;</p><p>l_sdept student.sdept%TYPE;</p><p>l_sql VARCHAR2(200);</p><p>type cur_type IS ref cursor; – 以下两句可以用这句 refCur SYS_REFCURSOR 代替;</p><p>cur cur_type;</p><p>stuRec student%ROWTYPE;</p><p>BEGIN</p><p>l_name := ‘&amp;Name’;</p><p>l_sdept := ‘&amp;dept’;</p><p>l_sql := ‘SELECT * FROM student WHERE 1=1 ‘;</p><p>IF l_name IS NOT NULL THEN</p><p>l_sql := l_sql || ‘AND sname=’’’||l_name||’’’’;</p><p>END IF;</p><p>IF l_sdept IS NOT NULL THEN</p><p>l_sql := l_sql || ‘AND sdept=’’’||l_sdept||’’’’;</p><p>END IF;</p><p>DBMS_OUTPUT.PUT_LINE(l_sql);</p><p>OPEN cur FOR l_sql;</p><p>LOOP</p><p>FETCH cur INTO stuRec;</p><p>EXIT WHEN cur%NOTFOUND;</p><p>DBMS_OUTPUT.PUT_LINE(stuRec.sname);</p><p>END LOOP;</p><p>CLOSE cur;</p><p>END;</p><p>/</p><p><strong>附加题：<strong>*</strong></strong></p><p>利用 SELECT … FOR UPDATE 游标和 UPDATE 语句中的 WHERE CURRENT OF 子句完成以下任务：</p><p>把所有年龄小于 18 岁的学员成绩增加 10 分。</p><p>DECLARE</p><p>tempScore NUMBER;</p><p>l_score NUMBER;</p><p>l_name VARCHAR2(50);</p><p>CURSOR stuCur IS</p><p>SELECT a.score , b.stuName FROM stuScore a,stuInfo b</p><p>WHERE a.stuId = b.stuId AND b.stuAge &lt; 18 FOR UPDATE OF a.score;</p><p>BEGIN</p><p>OPEN stuCur;</p><p>LOOP</p><p>FETCH stuCur INTO l_score,l_name;</p><p>EXIT WHEN stuCur%NOTFOUND;</p><p>tempScore := l_score + 10;</p><p>IF l_score &gt;= 90 THEN</p><p>tempScore := 99;</p><p>END IF;</p><p>UPDATE stuScore SET score = tempScore</p><p>WHERE CURRENT OF stuCur;</p><p>DBMS_OUTPUT.PUT_LINE(‘已经更新:’||l_name);</p><p>END LOOP;</p><p>CLOSE stuCur;</p><p>COMMIT;</p><p>END;</p><p><strong>二、</strong> <strong>实验报告</strong></p><p>根据实验内容要求写出相应的 PL/SQL 程序，并记录实验过程中遇到的困难和解决问</p><p>题的方法。(实验报告中不要求写加*题目和附加题的实验过程和内容)<br></p><p><strong>一、</strong> <strong>实验目的</strong></p><p><strong>《数据库开发技术》课程之实验六</strong></p><p><strong>PL/SQL</strong> <strong>复合数据类型：记录、表和可变数组</strong></p><ol><li><p>掌握如何创建 PL/SQL 记录 。</p></li><li><p>会用%ROWTYPE 属性创建一个记录。</p></li><li><p>掌握如何创建 PL/SQL 表和记录表。</p></li><li><p>掌握那些能获得复合数据信息的内置方法的使用。</p></li><li><p>掌握可变数组的使用。</p></li></ol><p><strong>二、</strong> <strong>实验内容和要求</strong></p><ol><li>根据表 emp 的全部字段定义记录变量 emp_record。用 SELECT 语句将编号为 7788 的雇员的全部字</li></ol><p>段对应地存入该记录变量，最后输出记录变量的雇员名称字段 emp_record.ename 和雇员工资字段</p><p>的内容。</p><p>SET SERVEROUTPUT ON</p><p>DECLARE</p><p>emp_record emp%ROWTYPE; –定义记录变量</p><p>BEGIN</p><p>SELECT * INTO emp_record</p><p>FROM emp</p><p>WHERE empno = 7788; –取出一条记录</p><p>DBMS_OUTPUT.PUT_LINE(emp_record.ename||’的工资为：’||</p><p>To_char(emp_record.sal)); –输出记录变量的某个字段</p><p>END;</p><p>执行结果如下：</p><p>SCOTT 的工资为：3000</p><p>PL/SQL 过程已成功完成。</p><ol start="2"><li>声明一张 Index_By 表，用来接收并存储 DEPT 表的信息，把部门号作为键，不要忘记部门号是 10</li></ol><p>的倍数。使用循环从 DEPT 表中将所有部门信息检索到 PL/SQL 记录表中，然后用另一个循环来显</p><p>示表中的这些信息。</p><p>DECLARE</p><p>TYPE dept_list_type IS TABLE OF dept%ROWTYPE index by binary_integer;</p><p>dept_list dept_list_type;</p><p>v_count number(3);</p><p>BEGIN</p><p>SELECT count(*) INTO v_count FROM dept;</p><p>FOR counter IN 1..v_count LOOP</p><p>SELECT <em>INTO dept_list(counter</em>10) FROM dept</p><p>WHERE deptno=counter*10;</p><p>END LOOP;</p><p>FOR COUNTER IN 1..v_count LOOP</p><p>DBMS_OUTPUT.PUT_LINE(to_char(dept_list(counter*10).deptno)||’, ‘||</p><p>dept_list(counter<em>10).dname||’, ‘||dept_list(counter</em>10).loc);</p><p>END LOOP;</p><p>END;</p><p>/</p><p>执行结果为：</p><p>10, ACCOUNTING, NEW YORK</p><p>20, RESEARCH, DALLAS</p><p>30, SALES, CHICAGO</p><p>40, OPERATIONS, BOSTON</p><p>PL/SQL 过程已成功完成。</p><ol start="3"><li>阅读以下程序，找出出错之处，说明出错原因，预测运行输出结果是什么。请删改错误，加上适当</li></ol><p>注释后，运行该程序，验证自己的预测是否正确。（注：实验报告中只要指出出错的语句和出错的原因</p><p>即可，不要抄原程序！）</p><p>SET SERVEROUTPUT ON</p><p>DECLARE</p><p>TYPE dept_list IS TABLE OF dept.dname%TYPE; –定义嵌套表</p><p>TYPE top5_list IS VARRAY(5) OF dept.loc%TYPE; –定义可变数组</p><p>dis_dept dept_list; –嵌套表的声明</p><p>num_5 top5_list; –可变数组的声明</p><p>BEGIN</p><p>/* 下 面的这 条 dis_dept(1):=’AMGN’ 赋值 语句是 非 法的， 因为 集合 尚未初始 化。出 现错 误提示</p><p>（ORA-06531: 引用未初始化的集合，是以下 ORA-06531 Reference to uninitialized collection 的翻</p><p>译）。集合变量的初始化是通过调用集合的构造函数来实现的，集合构造函数与集合对象（而不是集合</p><p>变量）同名。改正的方法有二。一是在集合变量声明的同时进行初始化，例如：</p><p>dis_dept dept_list :=dept_list(‘AMGN’, ‘BGEN’); 也可以在变量声明之后再进行初始化，例如：</p><p>dis_dept dept_list;</p><p>……</p><p>dis_dept :=dept_list(‘AMGN’,’BGEN’);</p><p>本题则可以直接将下面的这条 dis_dept(1):=’AMGN’ 语句删除即可。</p><p>*/</p><p>– dis_dept(1):=’AMGN’;</p><p>IF dis_dept IS NULL THEN</p><p>–显式调用构造函数进行集合的初始化</p><p>dis_dept :=dept_list(‘AMGN’,’BGEN’);</p><p>DBMS_OUTPUT.PUT_LINE(‘dis_dept 表当前元素个数为：’||to_char(dis_dept.count));</p><p>END IF;</p><p>num_5:=top5_list(‘ORCL’,’CSCO’,NULL,NULL);</p><p>IF num_5(3) IS NULL THEN</p><p>num_5(3):=’CPQ’;</p><p>END IF;</p><p>num_5(4):=’DELL’;</p><p>FOR COUNTER IN 1..4 LOOP</p><p>DBMS_OUTPUT.PUT_LINE(NUM_5(COUNTER));</p><p>END LOOP;</p><p>END;</p><p>/</p><p>执行结果为：</p><p>dis_dept 表当前元素个数为：2</p><p>ORCL</p><p>CSCO</p><p>CPQ</p><p>DELL</p><p>PL/SQL 过程已成功完成。</p><p><strong>以下是另一个相关的例子：</strong></p><p>SET SERVEROUTPUT ON</p><p>DECLARE</p><p>TYPE dept_list IS TABLE OF dept.dname%TYPE; –定义嵌套表</p><p>TYPE top5_list IS VARRAY(5) OF dept.loc%TYPE; –定义可变数组</p><p>dis_dept dept_list; –嵌套表的声明</p><p>num_5 top5_list; –可变数组的声明</p><p>v_count number(3);</p><p>BEGIN</p><p>IF dis_dept IS NULL THEN</p><p>–嵌套表要显式调用构造函数进行集合的初始化</p><p>dis_dept :=dept_list(‘AMGN’,’BGEN’);</p><p>DBMS_OUTPUT.PUT_LINE(‘dis_dept 表当前元素个数为：’||to_char(dis_dept.count));</p><p>dis_dept.extend(2);</p><p>dis_dept(3):=’EXTEND_ELEMENT’;</p><p>v_count:=dis_dept.count;</p><p>–嵌套表必须使用 extend(n)动态增加元素</p><p>DBMS_OUTPUT.PUT_LINE(‘dis_dept 表扩充后的元素个数为：’||to_char(dis_dept.count));</p><p>FOR i IN 1.. v_count loop –输出嵌套表 dis_dept 的内容</p><p>DBMS_OUTPUT.PUT_LINE(dis_dept(i));</p><p>END LOOP;</p><p>END IF;</p><p>num_5:=top5_list(‘ORCL’,’CSCO’,NULL,NULL);</p><p>IF num_5(3) IS NULL THEN</p><p>num_5(3):=’CPQ’;</p><p>END IF;</p><p>num_5(4):=’DELL’;</p><p>FOR COUNTER IN 1..4 LOOP</p><p>DBMS_OUTPUT.PUT_LINE(NUM_5(COUNTER));</p><p>END LOOP;</p><p>END;</p><p>/</p><p>执行结果为：</p><p>dis_dept 表当前元素个数为：2</p><p>dis_dept 表扩充后的元素个数为：4</p><p>AMGN</p><p>BGEN</p><p>EXTEND_ELEMENT</p><p>ORCL</p><p>CSCO</p><p>CPQ</p><p>DELL</p><p>PL/SQL 过程已成功完成。</p><ol start="4"><li>*将上题改为使用 INDEX BY BINARY_INTEGER 的索引表，则实现同一执行结果，程序要做哪些</li></ol><p>相应的改变。</p><p>DECLARE</p><p>TYPE dept_list IS TABLE OF dept.dname%TYPE index by binary_integer; –定义索引组织表</p><p>TYPE top5_list IS VARRAY(5) OF dept.loc%TYPE;</p><p>dis_dept dept_list;</p><p>num_5 top5_list;</p><p>BEGIN</p><p>dis_dept(1):=’AMGN’; –为表元素赋值</p><p>IF not dis_dept.exists(2) THEN</p><p>dis_dept(2) :=’BGEN’;</p><p>DBMS_OUTPUT.PUT_LINE(‘dis_dept 表当前元素个数为：’||to_char(dis_dept.count));</p><p>END IF;</p><p>num_5:=top5_list(‘ORCL’,’CSCO’,NULL,NULL);</p><p>IF num_5(3) IS NULL THEN</p><p>num_5(3):=’CPQ’;</p><p>END IF;</p><p>num_5(4):=’DELL’;</p><p>FOR COUNTER IN 1..4 LOOP</p><p>DBMS_OUTPUT.PUT_LINE(NUM_5(COUNTER));</p><p>END LOOP;</p><p>END;</p><p>/</p><p>执行结果为：</p><p>dis_dept 表当前元素个数为：2</p><p>ORCL</p><p>CSCO</p><p>CPQ</p><p>DELL</p><p>PL/SQL 过程已成功完成。</p><p><strong>以下是与上题对应的另一个相关的例子：</strong></p><p>SET SERVEROUTPUT ON</p><p>DECLARE</p><p>TYPE dept_list IS TABLE OF dept.dname%TYPE index by binary_integer; –定义索引组织表</p><p>TYPE top5_list IS VARRAY(5) OF dept.loc%TYPE; –定义可变数组</p><p>dis_dept dept_list; –索引表的声明</p><p>num_5 top5_list; –可变数组的声明</p><p>v_count number(3);</p><p>BEGIN</p><p>dis_dept(1):=’AMGN’; –为表元素赋值</p><p>IF not dis_dept.exists(2) THEN</p><p>DBMS_OUTPUT.PUT_LINE(‘dis_dept 表当前元素个数为：’||to_char(dis_dept.count));</p><p>– dis_dept.extend(2);</p><p>dis_dept(3):=’EXTEND_ELEMENT’;</p><p>v_count:=dis_dept.count;</p><p>–索引表无须使用 extend(n)增加元素，使用了反而出错</p><p>DBMS_OUTPUT.PUT_LINE(‘dis_dept 表增添元素后的个数为：’||to_char(dis_dept.count));</p><p>FOR i IN 1.. v_count loop</p><p>DBMS_OUTPUT.PUT_LINE(dis_dept(i));</p><p>END LOOP;</p><p>END IF;</p><p>num_5:=top5_list(‘ORCL’,’CSCO’,NULL,NULL);</p><p>IF num_5(3) IS NULL THEN</p><p>num_5(3):=’CPQ’;</p><p>END IF;</p><p>num_5(4):=’DELL’;</p><p>FOR COUNTER IN 1..4 LOOP</p><p>DBMS_OUTPUT.PUT_LINE(NUM_5(COUNTER));</p><p>END LOOP;</p><p>END;</p><p>/</p><p>执行结果为：</p><p>dis_dept 表当前元素个数为：2</p><p>dis_dept 表增添元素后的个数为：3</p><p>AMGN</p><p>BGEN</p><p>EXTEND_ELEMENT</p><p>ORCL</p><p>CSCO</p><p>CPQ</p><p>DELL</p><p>PL/SQL 过程已成功完成。</p><p><strong>附加题：</strong></p><p>*分割省份信息放入嵌套表结构中。用户输入：湖南|河南|江西，按”|”分割省份。</p><p>1) 接受用户输入</p><p>2) 分割字符串，把省份分割出放入嵌套表结构中</p><p>3) 遍历输出嵌套表</p><p>提示：str := ‘&amp;STR’ – str:= ‘湖南|河南|江西’;</p><p>SET SERVEROUTPUT ON</p><p>DECLARE</p><p>TYPE prov_type IS TABLE OF varchar(15); –定义嵌套表</p><p>prov_list prov_type:=prov_type(); –嵌套表的声明与初始化</p><p>str varchar(150);</p><p>v_loc number(3);</p><p>v_count number(2):=1;</p><p>BEGIN</p><p>str:= ‘&amp;STR’; – str:= ‘湖南|河南|江西’;</p><p>LOOP</p><p>v_loc :=instr(str,’|’,1);</p><p>prov_list.extend;</p><p>IF v_loc=0 THEN</p><p>prov_list(v_count):=str;</p><p>EXIT;</p><p>ELSE</p><p>prov_list(v_count):=substr(str,1,v_loc-1);</p><p>str:=substr(str,v_loc+1);</p><p>v_count:=v_count+1;</p><p>END IF;</p><p>END LOOP;</p><p>DBMS_OUTPUT.PUT_LINE(‘用户输入的省份显示如下：’);</p><p>FOR i IN 1.. v_count loop –输出嵌套表 prov_list 的内容</p><p>DBMS_OUTPUT.PUT_LINE(prov_list(i));</p><p>END LOOP;</p><p>END;</p><p>/</p><ol start="5"><li>参照教材和课件中的相关例子，自选实例使用复合数据的各种内置方法。</li></ol><p><strong>三、</strong> <strong>实验报告</strong></p><p>根据实验内容要求写出相应的 PL/SQL 程序，并记录实验过程中遇到的困难和解决问</p><p>题的方法。(实验报告中不要求写加*题目和附加题的实验过程和内容)<br></p><p><strong>《数据库开发技术》课程之实验七</strong></p><p><strong>PL/SQL</strong> <strong>过程和函数</strong></p><p><strong>一、</strong> <strong>实验目的</strong></p><p>1． 掌握正确使用异常处理的方法。</p><p>2． 掌握局部（本地）过程和存储过程的正确使用方法。</p><p>3． 掌握局部（本地）函数和存储函数的正确使用方法。</p><p><strong>二、</strong> <strong>实验内容和要求</strong></p><ol><li>创建一个显示 EMP 表中雇员总人数的存储过程。然后在程序块中和 SQL*Plus 环境中调用该存储过</li></ol><p>程。</p><p>CREATE OR REPLACE PROCEDURE EMP_COUNT</p><p>AS</p><p>V_TOTAL NUMBER(10);</p><p>BEGIN</p><p>SELECT COUNT(*) INTO V_TOTAL FROM EMP;</p><p>DBMS_OUTPUT.PUT_LINE(‘雇员总人数为：’||V_TOTAL);</p><p>END;</p><p>/<em> 在匿名块中调用：</em>/</p><p>BEGIN</p><p>EMP_COUNT;</p><p>END;</p><p>/<em> 在 SQL</em>Plus 环境中调用：*/</p><p>Exec[ute] EMP_COUNT;</p><p>执行结果：</p><p>雇员总人数为：14</p><ol start="2"><li>编写一个存储函数函数，用于判断 DEPT 表中某一编号的部门是否存在，若存在此部门编号，则返</li></ol><p>回 TRUE，否则返回 FALSE。</p><p>CREATE OR REPLACE FUNCTION GET_DNO(P_DNO IN NUMBER)</p><p>RETURN BOOLEAN IS</p><p>V_DNO EMP.DEPTNO%TYPE;</p><p>BEGIN</p><p>SELECT DISTINCT DEPTNO INTO V_DNO FROM EMP</p><p>WHERE DEPTNO=P_DNO;</p><p>RETURN TRUE;</p><p>EXCEPTION</p><p>WHEN NO_DATA_FOUND THEN</p><p>RETURN FALSE;</p><p>END;</p><ol start="3"><li>编写一过程，调用第 2 题的函数判断某一编号的部门是否存在，存在则输出该部门员工的姓名、工</li></ol><p>作，否则提示不存在此部门或此部门无员工。</p><p>CREATE OR REPLACE PROCEDURE DEMP_OUT (P_DNO IN NUMBER) IS</p><p>BEGIN</p><p>IF GET_DNO(P_DNO) THEN</p><p>FOR EMP_REC IN (SELECT ENAME,JOB FROM EMP</p><p>WHERE DEPTNO=P_DNO) LOOP</p><p>DBMS_OUTPUT.PUT_LINE(‘姓名: ’|| EMP_REC.ENAME||lpad(‘ ‘,3)||‘工作: ’|| EMP_REC.JOB);</p><p>END LOOP;</p><p>ELSE</p><p>DBMS_OUTPUT.PUT_LINE(‘没有此部门号！’);</p><p>END IF;</p><p>END;</p><ol start="4"><li>编写一个 PL/SQL 程序块调用第 2 题的存储函数，查询并显示 30 号部门的人数。</li></ol><p>DECLARE</p><p>v_deptno dept.deptno%type;</p><p>v_count int;</p><p>e_null exception;</p><p>BEGIN</p><p>v_deptno:=30;</p><p>IF GET_DNO(v_deptno) THEN</p><p>SELECT COUNT(*) INTO v_count FROM EMP WHERE deptno= v_deptno;</p><p>DBMS_OUTPUT.PUT_LINE(to_char(v_deptno)||’号部门的人数为：’|| to_char (v_count)|| ‘人’);</p><p>END IF;</p><p>EXCEPTION</p><p>when others then</p><p>raise_application_error(-20002,’程序运行过程中出现错误号为’||sqlcode||’错误信息为’||sqlerrm||’的错</p><p>误，请与系统管理员联系，以便尽快解决问题。’);</p><p>END;</p><p>执行结果：</p><p>30 号部门的人数为：6 人</p><p>PL/SQL 过程已成功完成。</p><ol start="5"><li>有一个权限控制的表中有三个字段，分别存放用户姓名、密码和权限级别。创建一个用户登录存储</li></ol><p>函数，用户登录时核对用户名和密码，正确则函数返回真，否则返回假。要求有适当的异常处理，</p><p>还要求进行适当的测试以验证函数的正确性。</p><p>Create table login(uname varchar(12), pw varchar(12), right_lel varchar(12));</p><p>insert into login values(‘xiaoli’,’12345’,’DBA’);</p><p>insert into login values(‘zhangsan’,’zzz’,’GUEST’);</p><p>create or replace function func_login(in_uname login.uname%type, in_pw login.pw%type)</p><p>return boolean</p><p>is</p><p>v_pw login.pw%type;</p><p>begin</p><p>select pw into v_pw from login where uname=in_uname;</p><p>if v_pw=in_pw then</p><p>return true;</p><p>else</p><p>return false;</p><p>end if;</p><p>exception</p><p>when no_data_found then</p><p>raise_application_error(-20001,’不存在用户名为’|| in_uname||’的用户!’);</p><p>when others then</p><p>raise_application_error(-20002,’程序运行过程中出现错误号为’||sqlcode||’错误信息为’||sqlerrm||’的错</p><p>误，请与系统管理员联系，以便尽快解决问题。’);</p><p>end func_login;</p><p>–登录函数测试</p><p>Set serveroutput on</p><p>Set verify off</p><p>Declare</p><p>v_uname login.uname%type:=’&amp;user_name’;</p><p>v_password login.pw%type:=’&amp;password’;</p><p>begin</p><p>if func_login(v_uname, v_password) then</p><p>dbms_output.put_line(‘登录成功!’);</p><p>else</p><p>dbms_output.put_line(‘用户密码有误!’);</p><p>end if;</p><p>end;</p><p>/</p><p>输入 user_name 的值: xiaoli</p><p>输入 password 的值: 12345</p><p>登录成功!</p><p>PL/SQL 过程已成功完成。</p><ol start="6"><li>*阅读、理解并执行以下程序，并在注释处完成填空，指明当条语句的作用或意义，一行不够写自行</li></ol><p>加一行注释。最后要求写出你的上机执行结果，对此执行结果写出一句总结。</p><p>DECLARE</p><p>TYPE EmpTabTyp IS TABLE OF emp%ROWTYPE; <span style="text-decoration:underline">– </span>定义一个嵌套表类型 <span style="text-decoration:underline">EmpTabTyp</span></p><p>emp_tab EmpTabTyp := EmpTabTyp(NULL); – <span style="text-decoration:underline">显式调用构造函数进行表</span> <span style="text-decoration:underline">emp_tab</span> <span style="text-decoration:underline">的初始化</span></p><p>t1 NUMBER(5);</p><p>t2 NUMBER(5);</p><p>t3 NUMBER(5);</p><p>PROCEDURE get_time (t OUT NUMBER) IS – 过程头：创建过程 <span style="text-decoration:underline">get_time</span>，过程有一个输出</p><p>–参<span style="text-decoration:underline">数</span><span style="text-decoration:underline"> t ,</span> 参数模式为 <span style="text-decoration:underline">OUT</span> <span style="text-decoration:underline">模式</span>，参数类型是 <span style="text-decoration:underline">NUMBER</span> <span style="text-decoration:underline">型</span>。</p><p>/<em> ‘SSSSS’日期/时间格式的含义为：距离午夜的秒数（0 ~ 86399）。</em>/</p><p>BEGIN –以下语句<span style="text-decoration:underline">将调用瞬间距离午夜的秒数以字符类型的形式</span>赋给输出参数 <span style="text-decoration:underline">t</span><span style="text-decoration:underline">。</span></p><p>SELECT TO_CHAR(SYSDATE,’SSSSS’) INTO t FROM dual;</p><p>END;</p><p>PROCEDURE do_nothing1 (tab IN OUT EmpTabTyp) IS –过程有一个 <span style="text-decoration:underline">IN OUT</span> 模式的参数 tab，数</p><p>– 据类型是嵌套表类型 <span style="text-decoration:underline">EmpTabTyp</span>，根据 PL/SQL 的默认方式，实参与形参间是按值传递的。</p><p>BEGIN</p><p>NULL; – 过程 do_nothing1 是一个什么也不做的过程</p><p>END;</p><p>PROCEDURE do_nothing2 (tab IN OUT NOCOPY EmpTabTyp) IS –过程有一个 IN OUT 模式的参</p><p>– 数 tab，实参与形参间由于有编译提示 <span style="text-decoration:underline">NOCOPY</span>，所以是按引用传递的。</p><p>BEGIN NULL; END;</p><p>BEGIN</p><p>SELECT * INTO emp_tab(1) FROM emp WHERE empno = 7788; – 将雇员 7788 的信息存入表元</p><p>– 素 1 中</p><p>emp_tab.EXTEND(249999, 1); <span style="text-decoration:underline">–</span> 向表 <span style="text-decoration:underline">emp_tab</span> 追加第 <span style="text-decoration:underline">1</span> 个元素的 <span style="text-decoration:underline">249999</span> 个拷贝，即将元素 <span style="text-decoration:underline">1</span> 的</p><p><span style="text-decoration:underline">–</span><span style="text-decoration:underline">值拷贝到表的</span> <span style="text-decoration:underline">2..250000</span> <span style="text-decoration:underline">位置中。</span></p><p>get_time(t1);</p><p>do_nothing1(emp_tab); – 将嵌套表 emp_tab 传递给过程 do_nothing1 的 IN OUT 形参</p><p>get_time(t2);</p><p>do_nothing2(emp_tab); – 将嵌套表 <span style="text-decoration:underline">emp_tab</span> 传递给过程 do_nothing2 的 IN OUT NOCOPY 形参</p><p>get_time(t3);</p><p>dbms_output.put_line(‘Call Duration (secs)’);</p><p>dbms_output.put_line(‘——————–’);</p><p>dbms_output.put_line(‘Just IN OUT: ‘ || TO_CHAR(t2 - t1)); –<span style="text-decoration:underline">显示出用值传递参数方式的执行用</span>时（秒）。</p><p>dbms_output.put_line(‘With NOCOPY: ‘ || TO_CHAR(t3 - t2)); –显示出用引用传递方式的执行用时（秒）。</p><p>END;</p><p>/</p><p>Call Duration (secs) –250000 条记录，即 25 万条记录</p><hr><p>Just IN OUT: 2</p><p>With NOCOPY: 0</p><p>PL/SQL 过程已成功完成。</p><p>Call Duration (secs) –2500000 条记录，即 250 万条记录</p><hr><p>Just IN OUT: 381</p><p>With NOCOPY: 0</p><p>PL/SQL 过程已成功完成。</p><p><strong>三、</strong> <strong>实验报告</strong></p><p>记录实验过程中遇到的困难和解决问题的方法。</p><p><strong>四、</strong> <strong>实验小结</strong></p><p>分析本次实验主要综合运用了哪些知识点，你的运用情况如何等。<br></p><p><strong>一、</strong> <strong>实验目的</strong></p><p><strong>《数据库开发技术》课程之实验八</strong></p><p><strong>PL/SQL</strong> <strong>的触发器与包</strong></p><p>1． 掌握正确使用触发器的方法。</p><p>2． 掌握包的正确使用方法。</p><p><strong>二、</strong> <strong>实验内容和要求</strong></p><ol><li>编写一个触发器，在 DEPT 表执行 INSERT 语句后被激发，此触发器将新部门的编号(deptno)、名称</li></ol><p>(dname)及执行此操作的用户（USER）、当时的日期（SYSDATE）插入 N_DEPT 表{注：此表已建好，</p><p>表结构为 N_DEPT（DEPTNO NUMBER(4),DNAME VARCHAR2(10), UNAME VARCHAR2(20),</p><p>INDATE DATE）}。</p><p>Create table N_DEPT (DEPTNO NUMBER(4),DNAME VARCHAR2(10), UNAME VARCHAR2(20),</p><p>INDATE DATE);</p><p>CREATE OR REPLACE TRIGGER T_DEPT_INS</p><p>AFTER INSERT ON DEPT</p><p>FOR EACH ROW</p><p>BEGIN</p><p>INSERT INTO N_DEPT VALUES (:new.deptno, :new.dname, user, sysdate);</p><p>COMMIT;</p><p>END;</p><p><strong>测试：</strong></p><p>INSERT INTO DEPT VALUES(50, ‘DEVELOP’, ‘BEIJING’)</p><p><strong>检查：</strong></p><p>SELECT * FROM N_DEPT;</p><p>DEPTNO DNAME UNAME INDATE</p><hr><p>50 DEVELOP SCOTT 04-6 月 -10</p><ol start="2"><li>创建触发器 CHECK_SAL，禁示对职务为 CLERK 的雇员的工资修改值超出 1000 至 2000 的范围，即</li></ol><p>CLERK 职务员工的修改后工资值只能在 1000~2000 之间。要求测试该触发器。</p><p>步骤 1：创建和编译以下触发器：</p><p>CREATE OR REPLACE TRIGGER check_sal</p><p>BEFORE</p><p>UPDATE <strong>OF sal</strong> ON emp</p><p>FOR EACH ROW</p><p><strong>WHEN (old.job=’CLERK’)</strong></p><p>BEGIN</p><p>IF :new.job=’CLERK’ AND (:new.sal&lt;1000 OR :new.sal&gt;2000) THEN</p><p>RAISE_APPLICATION_ERROR(-20001, ‘工资修改值超出 1000 至 2000 的范围, 操作取消！’);</p><p>END IF;</p><p>END;</p><p>步骤 2：在 EMP 表中修改记录，对触发器进行测试：</p><p>UPDATE emp SET sal=800 WHERE empno=7876;</p><p>执行结果：</p><p>UPDATE emp SET sal=800 WHERE empno=7876</p><p>*</p><p>ERROR 位于第 1 行:</p><p>ORA-20001: 工资修改值超出 1000 至 2000 的范围, 操作取消！</p><p>ORA-06512: 在”***.CHECK_SAL”, line 3</p><p>ORA-04088: 触发器 ‘***.CHECK_SAL’ 执行过程中出错</p><ol start="3"><li>*编写一个管理雇员信息的包 emp_mgmt。包中有成员如下：</li></ol><p>程序结构</p><p>类型</p><p>说明</p><p>Emp_count</p><p>init</p><p>tax_emp</p><p>Hire_emp</p><p>Fire_emp</p><p>公有变量 跟踪员工的总人数变化，插入和删除员工时要修改该变量的值</p><p>公有过程 初始化包，初始化员工人数和当前个人所得税率，建议有一个输入参数</p><p>p_tax，传入当前个人所得税率，暂定为工资的 8%。</p><p>公有函数 通过员工编号计算出员工应交个人所得税款</p><p>公有过程 通过员工编号插入员工</p><p>公有过程 通过员工编号删除员工</p><p><strong>emp_tax_record</strong> 记录</p><p>用于游标 C_emp 的 RETURN（强类型游标）语句中</p><p>C_emp</p><p>游标</p><p>用于游标 FOR 循环中，会被过程 show_emp_tax 所使用</p><p>show_emp_tax</p><p>Exist_emp</p><p>公有过程 按工资升序输出所有雇员的应交所得税清单</p><p>私有函数 判断某个编号的员工是否存在，该函数会被 hire_emp 和 fire_emp 等过程调</p><p>用</p><p>sal_null</p><p>……</p><p>异常名</p><p>公有或私</p><p>有变量</p><p>工资为空值时的异常名</p><p>可加入你认为需要的各种变量，但在程序中要有变量用途的注释</p><p><strong>步骤</strong> <strong>1**</strong>：创建包头和包体：**</p><p>CREATE OR REPLACE PACKAGE emp_mgmt – 包头部分</p><p>IS</p><p>EMP_COUNT NUMBER(5);</p><p>TYPE emp_tax_record IS RECORD</p><p>– 员工总人数</p><p>(Empno NUMBER(4), Ename emp.ename%type, Salary NUMBER ); – 记录定义</p><p>CURSOR c_emp RETURN emp_tax_record; – 游标定义</p><p>Sal_null EXCEPTION; – 异常名定义</p><p>PROCEDURE INIT(p_tax NUMBER); – 初始化过程</p><p>FUNCTION tax_emp(p_Empno emp.empno%type) – 函数：计算员工应交个人所得税款</p><p>RETURN number;</p><p>PROCEDURE hire_emp (P_EMPNO NUMBER, P_ENAME VARCHAR2, P_JOB VARCHAR2,</p><p>P_SAL NUMBER);</p><p>PROCEDURE Fire_emp(P_EMPNO NUMBER);</p><p>– 插入员工</p><p>– 删除雇员</p><p>PROCEDURE show_emp_tax; –按工资升序输出所有雇员的应交所得税清单</p><p>END emp_mgmt;</p><p>执行结果：</p><p>程序包已创建。</p><p>CREATE OR REPLACE PACKAGE BODY emp_mgmt – 包体部分</p><p>IS</p><p>CURSOR c_Emp RETURN emp_tax_record IS</p><p>SELECT empno, ename, sal FROM emp ORDER BY sal;</p><p>V_tax NUMBER; – 存放当前个人所得税率</p><p>——————–私有函数：判断员工是否存在—————————-</p><p>FUNCTION EXIST_EMP(P_EMPNO IN emp.empno%type)</p><p>RETURN BOOLEAN –判断雇员是否存在的私有函数</p><p>IS</p><p>V_NUM int;</p><p>BEGIN</p><p>SELECT COUNT(*) INTO V_NUM FROM EMP WHERE EMPNO= P_EMPNO;</p><p>IF V_NUM=1 THEN</p><p>RETURN TRUE;</p><p>ELSE</p><p>RETURN FALSE;</p><p>END IF;</p><p>END EXIST_EMP;</p><p>——————————- 初始化过程 —————————-</p><p>PROCEDURE INIT(p_tax NUMBER)</p><p>IS</p><p>BEGIN</p><p>SELECT COUNT(*) INTO EMP_COUNT FROM EMP;</p><p>V_tax:= p_tax;</p><p>DBMS_OUTPUT.PUT_LINE(‘当前个人所得税率：’||V_tax||’%’);</p><p>DBMS_OUTPUT.PUT_LINE(‘当前雇员总人数’||EMP_COUNT);</p><p>DBMS_OUTPUT.PUT_LINE(‘初始化过程已经完成！’);</p><p>END INIT;</p><p>——————公有函数：通过员工编号计算出员工应交个人所得税款—————————-</p><p>FUNCTION tax_emp (p_Empno emp.empno%type)</p><p>RETURN NUMBER – 定义该函数返回的数据类型，只能定义</p><p>IS – 数据类型，不能定义长度</p><p>v_Sal NUMBER;</p><p>v_ReturnValue NUMBER;</p><p>BEGIN</p><p>IF EXIST_EMP(P_EMPNO) THEN</p><p>SELECT sal INTO v_Sal FROM emp WHERE empno=p_Empno;</p><p>IF V_SAL IS NULL THEN</p><p>RAISE sal_null;</p><p>ELSE</p><p>v_ReturnValue:=v_Sal* V_tax;</p><p>RETURN v_ReturnValue; – 返回语句，确定该函数返回的值</p><p>END IF;</p><p>END IF;</p><p>Exception</p><p>when sal_null then</p><p>raise_application_error(-20001, p_empno||’号员工工资为空，无所得税！’);</p><p>when others then</p><p>raise_application_error(-20002,’程序运行过程中出现错误号为 ‘||sqlcode||’错误信息为’||sqlerrm||’的错</p><p>误!’);</p><p>END tax_emp;</p><p>——————公有过程：通过员工编号插入员工—————————-</p><p>PROCEDURE hire_emp (P_EMPNO NUMBER, P_ENAME VARCHAR2, P_JOB VARCHAR2,</p><p>P_SAL NUMBER)</p><p>IS</p><p>BEGIN</p><p>IF NOT EXIST_EMP(P_EMPNO) THEN</p><p>INSERT INTO emp (EMPNO,ENAME,JOB,SAL) VALUES (P_EMPNO, P_ENAME, P_JOB, P_SAL);</p><p>COMMIT;</p><p>EMP_COUNT:= EMP_COUNT + 1;</p><p>DBMS_OUTPUT.PUT_LINE(‘雇员’||P_EMPNO||’已插入!’);</p><p>DBMS_OUTPUT.PUT_LINE(‘当前雇员总人数’||EMP_COUNT);</p><p>ELSE</p><p>DBMS_OUTPUT.PUT_LINE(‘雇员’||P_EMPNO||’已存在,不能插入!’);</p><p>END IF;</p><p>EXCEPTION</p><p>WHEN OTHERS THEN</p><p>DBMS_OUTPUT.PUT_LINE(‘雇员’||P_EMPNO||’插入失败!’);</p><p>END hire_emp;</p><p>——————公有过程：通过员工编号删除员工—————————-</p><p>PROCEDURE Fire_emp(P_EMPNO NUMBER)</p><p>IS</p><p>BEGIN</p><p>IF EXIST_EMP(P_EMPNO) THEN</p><p>DELETE FROM EMP WHERE EMPNO=P_EMPNO;</p><p>COMMIT;</p><p>EMP_COUNT:= EMP_COUNT - 1;</p><p>DBMS_OUTPUT.PUT_LINE(‘雇员’||P_EMPNO||’已删除!’);</p><p>DBMS_OUTPUT.PUT_LINE(‘当前雇员总人数’||EMP_COUNT);</p><p>ELSE</p><p>DBMS_OUTPUT.PUT_LINE(‘雇员’||P_EMPNO||’不存在，不能删除!’);</p><p>END IF;</p><p>EXCEPTION</p><p>WHEN OTHERS THEN</p><p>DBMS_OUTPUT.PUT_LINE(‘雇员’||P_EMPNO||’删除失败!’);</p><p>END Fire_emp;</p><p>——————公有过程：按工资升序输出所有雇员的应交所得税清单—————————-</p><p>PROCEDURE show_emp_tax</p><p>IS</p><p>BEGIN</p><p>FOR emp_tax_record IN c_Emp LOOP –输出雇员的所得税</p><p>DBMS_OUTPUT.PUT_LINE(emp_tax_record.empno||’, ‘|| emp_tax_record.ename||’’’ tax is ‘</p><p>||TO_CHAR(tax_emp (emp_tax_record.Empno))||’.’);</p><p>END LOOP;</p><p>DBMS_OUTPUT.PUT_LINE(‘当前雇员总人数：’||EMP_COUNT);</p><p>END show_emp_tax;</p><p>END emp_mgmt;</p><p>执行结果：</p><p>程序包主体已创建。</p><p><strong>步骤</strong> <strong>2**</strong>：初始化包：**</p><p>SET SERVEROUTPUT ON</p><p>EXECUTE emp_mgmt.INIT(8);</p><p>执行结果：</p><p>当前个人所得税率：8%</p><p>当前雇员总人数 16</p><p>初始化过程已经完成！16</p><p><strong>步骤</strong> <strong>3**</strong>：按工资升序输出所有雇员的应交所得税清单：**</p><p>EXECUTE emp_mgmt.INIT(8);</p><p>EXECUTE emp_mgmt.show_emp_tax;</p><p>执行结果：</p><p>7369, SMITH’ tax is 7744.</p><p>7900, JAMES’ tax is 9196.</p><p>7876, ADAMS’ tax is 10648.</p><p>7521, WARD’ tax is 12100.</p><p>7654, MARTIN’ tax is 12100.</p><p>7934, MILLER’ tax is 12584.</p><p>7844, TURNER’ tax is 14520.</p><p>7499, ALLEN’ tax is 15488.</p><p>7951, OLIVEN’ tax is 20328.</p><p>7782, CLARK’ tax is 23716.</p><p>7948, MIKE’ tax is 26136.</p><p>7698, BLAKE’ tax is 27588.</p><p>7566, JONES’ tax is 28798.</p><p>7788, SCOTT’ tax is 29040.</p><p>7902, FORD’ tax is 29040.</p><p>7839, KING’ tax is 48400.</p><p>当前雇员总人数: 16</p><p>PL/SQL 过程已成功完成。</p><p><strong>步骤</strong> <strong>4**</strong>：对员工表插入一条新记录：**</p><p>EXECUTE emp_mgmt.hire_emp (8001,’小王’,’CLERK’,1000);</p><p>执行结果：</p><p>雇员 8001 已插入!</p><p>当前雇员总人数 17</p><p>PL/SQL 过程已成功完成。</p><p><strong>步骤</strong> <strong>5**</strong>：通过全局变量<strong> </strong>EMP_COUNT<strong> </strong>查看雇员人数：**</p><p>BEGIN</p><p>DBMS_OUTPUT.PUT_LINE(‘当前雇员总人数：’||emp_mgmt.EMP_COUNT);</p><p>END;</p><p>显示结果为：</p><p>当前雇员总人数：17</p><p>PL/SQL 过程已成功完成。</p><p><strong>步骤</strong> <strong>6**</strong>：删除员工表新插入的记录**</p><p>EXECUTE emp_mgmt.fire_emp(8001);</p><p>执行结果：</p><p>雇员 8001 删除失败! – 因为存在禁止删除的触发器，要执行 drop trigger emp_test;</p><p>PL/SQL 过程已成功完成。</p><p>删除触发器后，再次执行：</p><p>EXECUTE emp_mgmt.fire_emp(8001);</p><p>执行结果：</p><p>雇员 8001 已删除!</p><p>当前雇员总人数 16</p><p>PL/SQL 过程已成功完成。</p><p><strong>步骤</strong> <strong>7**</strong>：通过员工编号计算出员工应交个人所得税款**</p><p>DECLARE</p><p>V_empno emp.empno%type;</p><p>BEGIN</p><p>V_empno:=7951;</p><p>DBMS_OUTPUT.PUT_LINE(V_empno ||’ 应交个人所得税款为：’|| emp_mgmt. tax_emp(V_empno));</p><p>END;</p><p>执行结果：</p><p>7951 应交个人所得税款为：20328</p><p>PL/SQL 过程已成功完成。</p><p><strong>三、</strong> <strong>实验报告</strong></p><p>记录实验内容 1 和 2。记录实验过程中遇到的困难和解决问题的方法。</p></div><div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="https://wx1.sinaimg.cn/mw690/4d6e3e3bgy1fo2im2qze8j20760763yz.jpg" alt="Kainy Guo wechat" style="width:200px;max-width:100%"><div>微信扫码，或订阅 <a href="https://blogs.kainy.cn/atom.xml" target="_blank">Feed</a> 解锁更多开发技能。</div></div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/oracle/" rel="tag"># oracle</a> <a href="/tags/数据库/" rel="tag"># 数据库</a> <a href="/tags/实验/" rel="tag"># 实验</a> <a href="/tags/答案/" rel="tag"># 答案</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2010/05/80后面临的十大心理问题/" rel="next" title="80后面临的十大心理问题"><i class="fa fa-chevron-left"></i> 80后面临的十大心理问题</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2010/05/计算机专业英语期末复习资料汇总/" rel="prev" title="计算机专业英语期末复习资料汇总">计算机专业英语期末复习资料汇总 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zMjMwNy84ODY4"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="//tva2.sinaimg.cn/crop.0.0.180.180.180/4d6e3e3bjw1e8qgp5bmzyj2050050aa8.jpg" alt="Kainy Guo"><p class="site-author-name" itemprop="name">Kainy Guo</p><p class="site-description motion-element" itemprop="description">Web开发工程师郭涛的博客，在这里记录成长点滴、生活感悟，分享Web开发技术、开发技巧</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">448</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">23</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">628</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2009 - <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Kainy Guo</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.3.1/velocity.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.3.1/velocity.ui.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script src="https://cdn.ravenjs.com/3.26.2/raven.min.js" crossorigin="anonymous"></script><script>Raven.config("https://02667cee74e4479f9e40d84049b8c252@babyparty.gqmg.com/1").install()</script><script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.3.2.js"></script><script type="text/javascript">location.href.indexOf("debug=1")>-1&&document.write('<script src="https://res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/vconsole/2.5.2/vconsole.min.js"><\/script>'),function(e,t){var n="env=miniprogram";if(location.search.indexOf(n)>0&&(document.cookie=n+";Path=/"),-1!==document.cookie.indexOf(n))wx.miniProgram.postMessage({data:{title:document.title}}),$("#__shareBtn")[0]||($($(".post-body")[0]).append('<div id="__shareBtn" style="                text-align: center;                background: #1aad19;                color: white;                font-size: 1.4em;                margin-top: 12px;                border-radius: 8px;            ">分享</div>'),$("#__shareBtn").on("click",function(){wx.miniProgram.navigateTo({url:"/pages/webview/share?webviewurl="+encodeURIComponent(location.href.replace(n,""))+"&title="+document.title})}));else if(document.getElementById("lv-container")){var i,o=e.getElementsByTagName(t)[0];if("function"==typeof LivereTower)return;i=e.createElement(t),i.src="https://cdn-city.livere.com/js/embed.dist.js",i.async=!0,o.parentNode.insertBefore(i,o)}}(document,"script")</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),n=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!1,n=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),o=decodeURIComponent(r.url),i=-1,l=-1,p=-1;if(""!=n&&a.forEach(function(e,t){i=n.indexOf(e),l=s.indexOf(e),(i>=0||l>=0)&&(c=!0,0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+o+"' class='search-result-title'>"+n+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;0>u&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),n.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("8RLDamMl5A27EOhFH2fU7AN0-gzGzoHsz","gVpxIyNY3brM8JXwCTGSNeG3")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript" charset="utf-8" defer src="https://kainy.cn/js/common.js"></script></body></html>